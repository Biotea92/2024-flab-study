# 1주차

## JVM(Java Virtual Machine)

### 참고 문서

- [The Java® Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se17/html/)
- [Java Virtual Machine Guide](https://docs.oracle.com/en/java/javase/17/vm/java-virtual-machine-technology-overview.html)
- [HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/en/java/javase/17/gctuning/introduction-garbage-collection-tuning.html)

### 정의

- JVM은 JAVA 프로그램이 어떠한 운영체제에서도 동일하게 실행될 수 있게 하는 플랫폼 독립적인 가상 머신이다.

### 특징

- 실제 컴퓨터와 마찬가지로 런타임에 다양한 메모리 영역을 조작한다.
- JVM은 JAVA 언어에 대해서는 전혀 모르고 바이너리 형식인 .class 파일만 알고 있다면 실행이 가능하다.
    - .class 파일은 JVM이 이해할 수 있는 JVM 명령어(바이트코드)와 기타 부가 정보를 담고 있다.
    - 꼭 .class 파일이어야하는 것은 아니고, JVM이 이해할 수만 있다면 JVM에서 호스팅될 수 있다.

### 구조

#### 런타임 데이터 영역 (Run-Time Data Areas)

JVM은 프로그램 실행 중에 사용되는 다양한 런타임 데이터 영역을 정의한다.  
이러한 데이터 영역 중 일부는 JVM 시작 시 생성되고 JVM이 종료될 때만 삭제된다.  
다른 데이터 영역은 스레드별로 이루어진다.  
스레드별 데이터 영역은 스레드가 생성될 때 생성되고 스레드가 종료될 때 소멸된다.

- PC 레지스터(The PC Register)
    - JVM의 각 스레드는 자신만의 PC(Program Counter) 레지스터를 가지고 있다.
    - JVM 스레드는 단 하나의 메소드만 실행한다. 메소드가 native 메소드가 아닌 경우 pc 레지스터는 현재 실행 중인 JVM 명령어의 주소를 포함하고 있다.
    - 스레드가 현재 실행 중인 메소드가 native 메소드인 경우 JVM의 pc 레지스터 값은 정의되지 않는다.
    - JVM의 pc 레지스터는 특정 플랫폼에서 returnAddress나 native pointer를 보유할 수 있을 만큼 충분히 넓다.
  > JVM의 각 스레드는 자신만의 pc 레지스터를 가지고 있어, 현재 실행 중인 메소드의 어느 부분을 실행하고 있는지 추적한다.  
  > 이 메소드가 자바 코드로 작성된 경우, pc 레지스터는 그 명령어의 정확한 위치(주소)를 가리킨다.
  > 하지만 네이티브 메소드(예: C나 C++로 작성된 메소드)를 실행 중일 때는 pc 레지스터의 값은 정해져 있지 않다.  
  > 이런 방식으로, 각 스레드는 독립적으로 명령어를 실행할 수 있으며, pc 레지스터는 실행 중인 코드의 위치를 추적하는 데 중요한 역할을 한다.
- JVM 스택(JVM Stacks)
    - JVM에서는 각 실행 중인 스레드가 자신만의 JVM 스택을 갖는다. 이 스택은 스레드가 생성될 때 함께 생성된다.
    - JVM 스택은 프레임이라는 구조를 저장하는데, 이는 지역 변수와 중간 계산 결과를 보관하며, 메소드 호출과 반환 과정에서 중요한 역할을 한다.
    - 스택은 직접 조작되지 않으며, 프레임을 넣거나 빼는(push/pop) 동작만 수행한다. 따라서 프레임은 힙(heap)에 할당될 수 있으며, JVM 스택의 메모리는 연속적일 필요가 없다.
    - JVM 스택은 고정된 크기를 가질 수도 있고, 필요에 따라 동적으로 확장 및 축소될 수도 있다. 고정 사이즈의 경우, 스택이 생성될 때 그 크기를 결정할 수 있다.
    - JVM 구현체는 프로그래머나 사용자가 JVM 스택의 초기 크기를 제어할 수 있게 하며, 동적으로 확장/축소되는 경우에는 최대 및 최소 크기를 제어할 수 있는 옵션을 제공할 수 있다.
    - StackOverflowError: 스레드가 수행하는 연산이 허용된 JVM 스택 크기를 초과하는 경우 발생한다.
    - OutOfMemoryError: JVM 스택이 동적으로 확장될 수 있는 경우에 확장을 시도하였으나 메모리가 충분하지 않아 확장할 수 없거나, 새 스레드를 위한 초기 JVM 스택을 생성할 때 충분한 메모리를
      확보할 수 없는 경우 발생한다.
  > JVM의 각 스레드는 자신만의 스택을 가지며, 이는 메소드의 호출과 반환 및 지역 변수를 관리하는 데 중요한 역할을 한다.  
  > 스택은 고정 크기일 수도 있고 필요에 따라 크기가 조절될 수도 있다. 메모리 문제로 인해 스택 관련 오류가 발생할 수 있다.

  > frame 에 대해 공부할 것
- 힙(Heap)
    - 힙은 JVM의 모든 스레드가 공유하는 메모리 영역이다.
    - 클래스 인스턴스와 배열에 대한 메모리가 할당되는 실행 시간 데이터 영역이다.
    - 힙은 가상 머신이 시작될 때 생성되며, 객체의 저장 공간은 자동 저장소 관리 시스템(가비지 컬렉터)에 의해 회수된다. 객체를 명시적으로 해제할 필요 없다.
    - JVM은 특정 유형의 자동 저장소 관리 시스템을 가정하지 않으며, 저장 관리 기술은 구현자의 시스템 요구 사항에 따라 선택될 수 있다.
    - 힙의 크기는 고정되거나 계산에 필요에 따라 확장되고, 더 큰 힙이 필요 없게 되면 축소될 수 있다. 힙을 위한 메모리는 연속적일 필요가 없다.
    - JVM 구현은 프로그래머나 사용자에게 힙의 초기 크기를 제어할 수 있는 옵션을 제공할 수 있으며, 힙이 동적으로 확장되거나 축소될 수 있는 경우 최대 및 최소 힙 크기를 제어할 수 있는 옵션도 제공될 수
      있다.
    - OutOfMemoryError: 자동 저장소 관리 시스템이 제공할 수 있는 것보다 더 많은 힙이 필요한 경우 발생한다.
  > JVM의 모든 스레드가 공유하는 힙은 클래스 인스턴스와 배열을 위한 메모리 공간이다.  
  > 가비지 컬렉터에 의해 자동으로 메모리 관리가 이루어지며, 필요에 따라 힙의 크기를 조절할 수 있다.  
  > 메모리가 부족할 때는 OutOfMemoryError가 발생할 수 있다.
- 메서드 영역(Method Area)
    - JVM에는 모든 스레드가 공유하는 메소드 영역이 있다. 이 영역에는 클래스 별 구조체, 메소드 및 생성자 코드, 클래스 및 인터페이스 초기화에 사용되는 특수 메소드 등이 저장된다.
    - 메소드 영역은 가상 머신이 시작될 때 생성되며, 논리적으로 힙의 일부이지만 가비지 컬렉션을 하지 않거나 압축하지 않는 간단한 구현을 선택할 수 있다.
    - 메소드 영역의 크기는 고정되어 있을 수도 있고, 필요에 따라 확장되고, 더 큰 메소드 영역이 필요 없게 되면 축소될 수 있다. 메소드 영역을 위한 메모리는 연속적일 필요가 없다.
    - JVM구현은 프로그래머나 사용자에게 메소드 영역의 초기 크기를 제어할 수 있는 옵션을 제공할 수 있으며, 크기가 변하는 메소드 영역의 경우 최대 및 최소 메소드 영역 크기를 제어할 수 있다.
    - OutOfMemoryError: 메소드 영역에서 할당 요청을 충족시키기 위해 사용할 수 있는 메모리를 확보할 수 없는 경우 발생한다.
  > JVM의 메소드 영역은 모든 스레드가 공유하는 곳으로, 클래스 별 구조체, 메소드 및 생성자 코드 등을 저장한다.
  > 메소드 영역의 크기는 필요에 따라 조정될 수 있으며, 메모리 할당에 실패하면 OutOfMemoryError가 발생할 수 있다.
- 런타임 상수 풀(Runtime Constant Pool)
    - 런타임 상수 풀은 클래스 파일의 constant_pool 테이블을 실행 시간에 클래스나 인터페이스별로 표현한 것이다.
    - 컴파일 시간에 알려진 숫자 리터럴부터 실행 시간에 해결해야 하는 메소드와 필드 참조에 이르기까지 다양한 종류의 상수를 포함한다.
    - 런타임 상수 풀은 전통적인 프로그래밍 언어의 심볼 테이블과 유사한 기능을 하지만, 일반적인 심볼 테이블보다 더 다양한 범위의 데이터를 포함한다.
    - 각각의 런타임 상수 풀은 JVM의 메소드 영역에서 할당된다. 클래스나 인터페이스의 런타임 상수 풀은 JVM에 의해 클래스나 인터페이스가 생성될 때 구성된다.
    - OutOfMemoryError: 클래스나 인터페이스를 생성할 때, 런타임 상수 풀의 구성에 필요한 메모리가 JVM의 메소드 영역에서 제공될 수 없는 경우 발생한다.
  > 런타임 상수 풀은 클래스나 인터페이스마다 실행 시간에 상수 정보를 저장하는 공간이다.
  > 다양한 상수를 포함하며, 메모리 부족 시 OutOfMemoryError가 발생할 수 있다.
- 네이티브 메서드 스택(Native Method Stacks)
    - JVM 구현에서는 "C 스택"이라고 불리는 전통적인 스택을 사용하여 네이티브 메소드를 지원할 수 있다.
    - 네이티브 메소드 스택은 C와 같은 언어로 자바 가상 머신의 명령어 세트에 대한 인터프리터 구현에 의해서도 사용될 수 있다.
    - 네이티브 메소드를 로드할 수 없고 전통적인 스택에 의존하지 않는 JVM 구현은 네이티브 메소드 스택을 제공할 필요가 없다. 제공된다면, 각 스레드가 생성될 때 스레드별로 할당된다.
    - 네이티브 메소드 스택은 고정 크기일 수도 있고, 필요에 따라 동적으로 확장되고 축소될 수도 있다. 네이티브 메소드 스택이 고정 크기인 경우, 각 스택의 크기는 해당 스택이 생성될 때 독립적으로 선택될 수
      있다.
    - JVM 구현은 프로그래머나 사용자가 네이티브 메소드 스택의 초기 크기를 제어할 수 있도록 할 수 있으며, 크기가 변하는 스택의 경우 최대 및 최소 스택 크기를 제어할 수 있다.
    - StackOverflowError: 스레드에서 계산이 허용된 것보다 더 큰 네이티브 메소드 스택을 요구하는 경우 발생한다.
    - OutOfMemoryError: 네이티브 메소드 스택을 동적으로 확장할 수 있으나 확장을 시도할 때 충분한 메모리를 확보할 수 없거나, 새 스레드에 대한 초기 스택을 생성하기 위해 충분한 메모리를 확보할
      수 없는 경우 발생한다.
  > JVM은 네이티브 메소드를 지원하기 위해 전통적인 스택을 사용할 수 있으며, 이러한 스택은 고정 크기이거나 필요에 따라 크기가 조정될 수 있다.
  > 스택 크기가 충분하지 않을 때는 에러가 발생할 수 있다.

#### Class Loader

> JVM의 시작은 Bootstrap Class Loader 또는 User-Defined Class Loader를 사용하여 초기 클래스나 인터페이스를 생성하는 것으로 시작된다.  
> 그 다음 JVM은 이 초기 클래스나 인터페이스를 연결(link)하고 초기화(initialize)하고, public static void main(String[] args) 메소드를 호출한다. 이 메소드의 호출은
> 모든 추가 실행을 시작한다.
> main 메소드를 구성하는 JVM 지시사항의 실행은 추가 클래스나 인터페이스의 연결(그리고 따라서 생성)과 추가 메소드의 호출을 유발할 수 있다.

- Class Loader는 JVM이 클래스를 읽어들이고, .class 파일로 부터 클래스를 생성하는데 사용된다.
- 동적 로딩(Dynamic Loading)을 지원하며, 이는 프로그램 실행 중에 필요할 때 클래스와 인터페이스를 로드(load), 링크(link), 초기화(initialize)하는 기능을 말한다.
- Class Loader에는 JVM에서 제공하는 Bootstrap Class Loader와 User-Defined Class Loader 두 가지 종류가 있다.

##### Bootstrap Class Loader

- JVM의 최상위 클래스 로더이다.
- JRE의 핵심 클래스 라이브러리(java.lang.*)를 로드 하는 역할을 한다.
- JVM 구현의 일부로, 자바 언어로 작성되지 않았다.
- 사용자가 직접 접근할 수 없다.

##### User-Defined Class Loader

- 개발자가 직접 작성한 클래스를 로드하는 역할을 한다.
- java.lang.ClassLoader 클래스를 상속받아 구현한다.
- 사용자가 직접 구현할 수 있어, 필요에 따라 매우 유연하게 확장하거나 수정할 수 있다.

##### Loading

- Class Loader가 .class 파일을 읽어들여 Method Area(Runtime Data Area의 메서드 영역)에 저장한다.

##### Linking

- class나 interface를 linking하는 과정은 해당 class나 interface, 그리고 그것의 직접적인 상위 class와 상위 interface, 배열 타입인 경우 그 요소 타입을 검증하고 준비하는
  것을 포함한다.
- 이 과정에는 class나 interface 내의 symbolic reference를 해결하는 작업도 포함되지만, 반드시 검증과 준비 단계와 동시에 이루어지지는 않는다.
- JVM 구현에서는 각각의 symbolic reference를 사용될 때마다 개별적으로 해결하는 lazy linking 전략을 선택할 수도 있고,
- 반대로 모든 symbolic reference를 클래스나 인터페이스가 검증되는 시점에 한꺼번에 해결하는 eager linking 전략을 선택할 수도 있다.

> Symbolic reference:
> 자바에서는 특정 객체를 참조할 때 메모리 주소를 직접 참조하는게 아니라, 객체의 이름으로 참조한다.
> 이렇게 객체의 이름으로 참조하는 것은 Symbolic reference라고 한다.
> Symbolic reference는 Constant Pool에 저장되며 객체에 접근할 필요가 있으면 Constant Pool에서 Symbolic reference를 통해 해당 객체의 메모리 주소를 찾아 동적으로
> 연결한다.

- Verify : 클래스나 인터페이스의 이진 표현이 올바른지 검증하는 단계
    - 검증 과정에서 추가적인 클래스나 인터페이스가 로드될 수 있지만, 반드시 검증되거나 준비될 필요는 없다.
    - 클래스나 인터페이스의 이진 표현이 정적 또는 구조적 제약 조건을 만족하지 못하면 VerifyError를 발생시킨다.
    - 한 번 검증에 실패한 클래스나 인터페이스는 다시 시도해도 같은 오류로 실패한다.
    - 검증 과정에서 추가적인 클래스나 인터페이스가 로드될 수 있지만, 반드시 검증되거나 준비될 필요는 없습니다.
- Prepare : 클래스나 인터페이스의 정적 필드를 생성하고, 이러한 필드들을 기본값으로 초기화하는 작업 과정
    - 이 과정에서는 JVM 코드의 실행이 필요하지 않으며, 정적 필드의 명시적 초기화는 초기화 단계에서 이루어지지 준비 단계에서는 이루어지지 않는다.
    - 클래스나 인터페이스가 다른 클래스나 인터페이스와 상호 작용할 때 특정한 로딩 제약 조건을 따라야 하며, 준비 과정은 초기화 과정 이전에 반드시 완료되어야 한다.
      JVM 지시문들이 실행될 때, 실행 시 상수 풀에 있는 기호 참조를 구체적인 값으로 해석하는 과정이 필요합니다. 이 과정은 처음에는 해결되지 않은 상태에서 시작하며, 오류 없이 성공적으로 해석되거나, 오류
      발생 시 해당 오류로 인해 실패합니다. 오류가 발생한 경우, 같은 기호 참조의 이후 해석 시도도 동일한 오류로 실패합니다.
- Resolution : 실행 시 상수 풀에 있는 symbolic reference로부터 하나 이상의 구체적인 값으로 해석하는 과정
    - 많은 지시문들(예: anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial,
      invokestatic, invokevirtual, ldc, ldc_w, ldc2_w, multianewarray, new, putfield, putstatic 등)은 실행 시 상수 풀(runtime
      constant pool)에 있는 symbolic references에 의존한다. 이러한 지시문의 실행은 symbolic references의 해석을 필요로 한다.

##### Initialization
초기화 단계는 클래스가 실제로 사용되기 전에 한 번만 수행되며, 이 단계에서 정적 변수의 초기화와 정적 초기화 블록의 실행이 이루어진다.



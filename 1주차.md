# 1주차

## JVM(Java Virtual Machine)

### 참고 문서

- [The Java® Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se17/html/)
- [Java Virtual Machine Guide](https://docs.oracle.com/en/java/javase/17/vm/java-virtual-machine-technology-overview.html)
- [HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/en/java/javase/17/gctuning/introduction-garbage-collection-tuning.html)
- [Naver JVM Internal](https://d2.naver.com/helloworld/1230)

### 정의

- JVM은 JAVA 프로그램이 어떠한 운영체제에서도 동일하게 실행될 수 있게 하는 플랫폼 독립적인 가상 머신이다.

### 특징

- 실제 컴퓨터와 마찬가지로 런타임에 다양한 메모리 영역을 조작한다.
- JVM은 JAVA 언어에 대해서는 전혀 모르고 바이너리 형식인 .class 파일만 알고 있다면 실행이 가능하다.
    - .class 파일은 JVM이 이해할 수 있는 JVM 명령어(바이트코드)와 기타 부가 정보를 담고 있다.
    - 꼭 .class 파일이어야하는 것은 아니고, JVM이 이해할 수만 있다면 JVM에서 호스팅될 수 있다.

### 구조

#### 런타임 데이터 영역 (Run-Time Data Areas)

JVM은 프로그램 실행 중에 사용되는 다양한 런타임 데이터 영역을 정의한다.  
이러한 데이터 영역 중 일부는 JVM 시작 시 생성되고 JVM이 종료될 때만 삭제된다.  
다른 데이터 영역은 스레드별로 이루어진다.  
스레드별 데이터 영역은 스레드가 생성될 때 생성되고 스레드가 종료될 때 소멸된다.

##### PC 레지스터(The PC Register)
- JVM의 각 스레드는 자신만의 PC(Program Counter) 레지스터를 가지고 있다.
- JVM 스레드는 단 하나의 메소드만 실행한다. 메소드가 native 메소드가 아닌 경우 pc 레지스터는 현재 실행 중인 JVM 명령어의 주소를 포함하고 있다.
- 스레드가 현재 실행 중인 메소드가 native 메소드인 경우 JVM의 pc 레지스터 값은 정의되지 않는다.
- JVM의 pc 레지스터는 특정 플랫폼에서 returnAddress나 native pointer를 보유할 수 있을 만큼 충분히 넓다.
> JVM의 각 스레드는 자신만의 pc 레지스터를 가지고 있어, 현재 실행 중인 메소드의 어느 부분을 실행하고 있는지 추적한다.  
> 이 메소드가 자바 코드로 작성된 경우, pc 레지스터는 그 명령어의 정확한 위치(주소)를 가리킨다.
> 하지만 네이티브 메소드(예: C나 C++로 작성된 메소드)를 실행 중일 때는 pc 레지스터의 값은 정해져 있지 않다.  
> 이런 방식으로, 각 스레드는 독립적으로 명령어를 실행할 수 있으며, pc 레지스터는 실행 중인 코드의 위치를 추적하는 데 중요한 역할을 한다.
##### JVM 스택(JVM Stacks)
- JVM에서는 각 실행 중인 스레드가 자신만의 JVM 스택을 갖는다. 이 스택은 스레드가 생성될 때 함께 생성된다.
- JVM 스택은 프레임이라는 구조를 저장하는데, 이는 지역 변수와 중간 계산 결과를 보관하며, 메소드 호출과 반환 과정에서 중요한 역할을 한다.
- 스택은 직접 조작되지 않으며, 프레임을 넣거나 빼는(push/pop) 동작만 수행한다. 따라서 프레임은 힙(heap)에 할당될 수 있으며, JVM 스택의 메모리는 연속적일 필요가 없다.
- JVM 스택은 고정된 크기를 가질 수도 있고, 필요에 따라 동적으로 확장 및 축소될 수도 있다. 고정 사이즈의 경우, 스택이 생성될 때 그 크기를 결정할 수 있다.
- JVM 구현체는 프로그래머나 사용자가 JVM 스택의 초기 크기를 제어할 수 있게 하며, 동적으로 확장/축소되는 경우에는 최대 및 최소 크기를 제어할 수 있는 옵션을 제공할 수 있다.
- StackOverflowError: 스레드가 수행하는 연산이 허용된 JVM 스택 크기를 초과하는 경우 발생한다.
- OutOfMemoryError: JVM 스택이 동적으로 확장될 수 있는 경우에 확장을 시도하였으나 메모리가 충분하지 않아 확장할 수 없거나, 새 스레드를 위한 초기 JVM 스택을 생성할 때 충분한 메모리를
  확보할 수 없는 경우 발생한다.
> JVM의 각 스레드는 자신만의 스택을 가지며, 이는 메소드의 호출과 반환 및 지역 변수를 관리하는 데 중요한 역할을 한다.  
> 스택은 고정 크기일 수도 있고 필요에 따라 크기가 조절될 수도 있다. 메모리 문제로 인해 스택 관련 오류가 발생할 수 있다.

  > frame 에 대해 공부할 것
##### 힙(Heap)
- 힙은 JVM의 모든 스레드가 공유하는 메모리 영역이다.
- 클래스 인스턴스와 배열에 대한 메모리가 할당되는 실행 시간 데이터 영역이다.
- 힙은 가상 머신이 시작될 때 생성되며, 객체의 저장 공간은 자동 저장소 관리 시스템(가비지 컬렉터)에 의해 회수된다. 객체를 명시적으로 해제할 필요 없다.
- JVM은 특정 유형의 자동 저장소 관리 시스템을 가정하지 않으며, 저장 관리 기술은 구현자의 시스템 요구 사항에 따라 선택될 수 있다.
- 힙의 크기는 고정되거나 계산에 필요에 따라 확장되고, 더 큰 힙이 필요 없게 되면 축소될 수 있다. 힙을 위한 메모리는 연속적일 필요가 없다.
- JVM 구현은 프로그래머나 사용자에게 힙의 초기 크기를 제어할 수 있는 옵션을 제공할 수 있으며, 힙이 동적으로 확장되거나 축소될 수 있는 경우 최대 및 최소 힙 크기를 제어할 수 있는 옵션도 제공될 수
  있다.
- OutOfMemoryError: 자동 저장소 관리 시스템이 제공할 수 있는 것보다 더 많은 힙이 필요한 경우 발생한다.
> JVM의 모든 스레드가 공유하는 힙은 클래스 인스턴스와 배열을 위한 메모리 공간이다.  
> 가비지 컬렉터에 의해 자동으로 메모리 관리가 이루어지며, 필요에 따라 힙의 크기를 조절할 수 있다.  
> 메모리가 부족할 때는 OutOfMemoryError가 발생할 수 있다.
##### 메서드 영역(Method Area)
- JVM에는 모든 스레드가 공유하는 메소드 영역이 있다. 이 영역에는 클래스 별 구조체, 메소드 및 생성자 코드, 클래스 및 인터페이스 초기화에 사용되는 특수 메소드 등이 저장된다.
- 메소드 영역은 가상 머신이 시작될 때 생성되며, 논리적으로 힙의 일부이지만 가비지 컬렉션을 하지 않거나 압축하지 않는 간단한 구현을 선택할 수 있다.
- 메소드 영역의 크기는 고정되어 있을 수도 있고, 필요에 따라 확장되고, 더 큰 메소드 영역이 필요 없게 되면 축소될 수 있다. 메소드 영역을 위한 메모리는 연속적일 필요가 없다.
- JVM구현은 프로그래머나 사용자에게 메소드 영역의 초기 크기를 제어할 수 있는 옵션을 제공할 수 있으며, 크기가 변하는 메소드 영역의 경우 최대 및 최소 메소드 영역 크기를 제어할 수 있다.
- OutOfMemoryError: 메소드 영역에서 할당 요청을 충족시키기 위해 사용할 수 있는 메모리를 확보할 수 없는 경우 발생한다.
> JVM의 메소드 영역은 모든 스레드가 공유하는 곳으로, 클래스 별 구조체, 메소드 및 생성자 코드 등을 저장한다.
> 메소드 영역의 크기는 필요에 따라 조정될 수 있으며, 메모리 할당에 실패하면 OutOfMemoryError가 발생할 수 있다.
##### 런타임 상수 풀(Runtime Constant Pool)
- 런타임 상수 풀은 클래스 파일의 constant_pool 테이블을 실행 시간에 클래스나 인터페이스별로 표현한 것이다.
- 컴파일 시간에 알려진 숫자 리터럴부터 실행 시간에 해결해야 하는 메소드와 필드 참조에 이르기까지 다양한 종류의 상수를 포함한다.
- 런타임 상수 풀은 전통적인 프로그래밍 언어의 심볼 테이블과 유사한 기능을 하지만, 일반적인 심볼 테이블보다 더 다양한 범위의 데이터를 포함한다.
- 각각의 런타임 상수 풀은 JVM의 메소드 영역에서 할당된다. 클래스나 인터페이스의 런타임 상수 풀은 JVM에 의해 클래스나 인터페이스가 생성될 때 구성된다.
- OutOfMemoryError: 클래스나 인터페이스를 생성할 때, 런타임 상수 풀의 구성에 필요한 메모리가 JVM의 메소드 영역에서 제공될 수 없는 경우 발생한다.
> 런타임 상수 풀은 클래스나 인터페이스마다 실행 시간에 상수 정보를 저장하는 공간이다.
> 다양한 상수를 포함하며, 메모리 부족 시 OutOfMemoryError가 발생할 수 있다.
##### 네이티브 메서드 스택(Native Method Stacks)
- JVM 구현에서는 "C 스택"이라고 불리는 전통적인 스택을 사용하여 네이티브 메소드를 지원할 수 있다.
- 네이티브 메소드 스택은 C와 같은 언어로 자바 가상 머신의 명령어 세트에 대한 인터프리터 구현에 의해서도 사용될 수 있다.
- 네이티브 메소드를 로드할 수 없고 전통적인 스택에 의존하지 않는 JVM 구현은 네이티브 메소드 스택을 제공할 필요가 없다. 제공된다면, 각 스레드가 생성될 때 스레드별로 할당된다.
- 네이티브 메소드 스택은 고정 크기일 수도 있고, 필요에 따라 동적으로 확장되고 축소될 수도 있다. 네이티브 메소드 스택이 고정 크기인 경우, 각 스택의 크기는 해당 스택이 생성될 때 독립적으로 선택될 수
  있다.
- JVM 구현은 프로그래머나 사용자가 네이티브 메소드 스택의 초기 크기를 제어할 수 있도록 할 수 있으며, 크기가 변하는 스택의 경우 최대 및 최소 스택 크기를 제어할 수 있다.
- StackOverflowError: 스레드에서 계산이 허용된 것보다 더 큰 네이티브 메소드 스택을 요구하는 경우 발생한다.
- OutOfMemoryError: 네이티브 메소드 스택을 동적으로 확장할 수 있으나 확장을 시도할 때 충분한 메모리를 확보할 수 없거나, 새 스레드에 대한 초기 스택을 생성하기 위해 충분한 메모리를 확보할
  수 없는 경우 발생한다.
> JVM은 네이티브 메소드를 지원하기 위해 전통적인 스택을 사용할 수 있으며, 이러한 스택은 고정 크기이거나 필요에 따라 크기가 조정될 수 있다.
> 스택 크기가 충분하지 않을 때는 에러가 발생할 수 있다.

#### Class Loader

> JVM의 시작은 Bootstrap Class Loader 또는 User-Defined Class Loader를 사용하여 초기 클래스나 인터페이스를 생성하는 것으로 시작된다.  
> 그 다음 JVM은 이 초기 클래스나 인터페이스를 연결(link)하고 초기화(initialize)하고, public static void main(String[] args) 메소드를 호출한다. 이 메소드의 호출은
> 모든 추가 실행을 시작한다.
> main 메소드를 구성하는 JVM 지시사항의 실행은 추가 클래스나 인터페이스의 연결(그리고 따라서 생성)과 추가 메소드의 호출을 유발할 수 있다.

- Class Loader는 JVM이 클래스를 읽어들이고, .class 파일로 부터 클래스를 생성하는데 사용된다.
- 동적 로딩(Dynamic Loading)을 지원하며, 이는 프로그램 실행 중에 필요할 때 클래스와 인터페이스를 로드(load), 링크(link), 초기화(initialize)하는 기능을 말한다.
- Class Loader에는 JVM에서 제공하는 Bootstrap Class Loader와 User-Defined Class Loader 두 가지 종류가 있다.

##### Bootstrap Class Loader

- JVM의 최상위 클래스 로더이다.
- JRE의 핵심 클래스 라이브러리(java.lang.*)를 로드 하는 역할을 한다.
- JVM 구현의 일부로, 자바 언어로 작성되지 않았다.
- 사용자가 직접 접근할 수 없다.

##### User-Defined Class Loader

- 개발자가 직접 작성한 클래스를 로드하는 역할을 한다.
- java.lang.ClassLoader 클래스를 상속받아 구현한다.
- 사용자가 직접 구현할 수 있어, 필요에 따라 매우 유연하게 확장하거나 수정할 수 있다.

##### Loading

- Class Loader가 .class 파일을 읽어들여 Method Area(Runtime Data Area의 메서드 영역)에 저장한다.

##### Linking

- class나 interface를 linking하는 과정은 해당 class나 interface, 그리고 그것의 직접적인 상위 class와 상위 interface, 배열 타입인 경우 그 요소 타입을 검증하고 준비하는
  것을 포함한다.
- 이 과정에는 class나 interface 내의 symbolic reference를 해결하는 작업도 포함되지만, 반드시 검증과 준비 단계와 동시에 이루어지지는 않는다.
- JVM 구현에서는 각각의 symbolic reference를 사용될 때마다 개별적으로 해결하는 lazy linking 전략을 선택할 수도 있고,
- 반대로 모든 symbolic reference를 클래스나 인터페이스가 검증되는 시점에 한꺼번에 해결하는 eager linking 전략을 선택할 수도 있다.

> Symbolic reference:
> 자바에서는 특정 객체를 참조할 때 메모리 주소를 직접 참조하는게 아니라, 객체의 이름으로 참조한다.
> 이렇게 객체의 이름으로 참조하는 것은 Symbolic reference라고 한다.
> Symbolic reference는 Constant Pool에 저장되며 객체에 접근할 필요가 있으면 Constant Pool에서 Symbolic reference를 통해 해당 객체의 메모리 주소를 찾아 동적으로
> 연결한다.

- Verify : 클래스나 인터페이스의 이진 표현이 올바른지 검증하는 단계
    - 검증 과정에서 추가적인 클래스나 인터페이스가 로드될 수 있지만, 반드시 검증되거나 준비될 필요는 없다.
    - 클래스나 인터페이스의 이진 표현이 정적 또는 구조적 제약 조건을 만족하지 못하면 VerifyError를 발생시킨다.
    - 한 번 검증에 실패한 클래스나 인터페이스는 다시 시도해도 같은 오류로 실패한다.
    - 검증 과정에서 추가적인 클래스나 인터페이스가 로드될 수 있지만, 반드시 검증되거나 준비될 필요는 없습니다.
- Prepare : 클래스나 인터페이스의 정적 필드를 생성하고, 이러한 필드들을 기본값으로 초기화하는 작업 과정
    - 이 과정에서는 JVM 코드의 실행이 필요하지 않으며, 정적 필드의 명시적 초기화는 초기화 단계에서 이루어지지 준비 단계에서는 이루어지지 않는다.
    - 클래스나 인터페이스가 다른 클래스나 인터페이스와 상호 작용할 때 특정한 로딩 제약 조건을 따라야 하며, 준비 과정은 초기화 과정 이전에 반드시 완료되어야 한다.
      JVM 지시문들이 실행될 때, 실행 시 상수 풀에 있는 기호 참조를 구체적인 값으로 해석하는 과정이 필요합니다. 이 과정은 처음에는 해결되지 않은 상태에서 시작하며, 오류 없이 성공적으로 해석되거나, 오류
      발생 시 해당 오류로 인해 실패합니다. 오류가 발생한 경우, 같은 기호 참조의 이후 해석 시도도 동일한 오류로 실패합니다.
- Resolution : 실행 시 상수 풀에 있는 symbolic reference로부터 하나 이상의 구체적인 값으로 해석하는 과정
    - 많은 지시문들(예: anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial,
      invokestatic, invokevirtual, ldc, ldc_w, ldc2_w, multianewarray, new, putfield, putstatic 등)은 실행 시 상수 풀(runtime
      constant pool)에 있는 symbolic references에 의존한다. 이러한 지시문의 실행은 symbolic references의 해석을 필요로 한다.

##### Initialization

초기화 단계는 클래스가 실제로 사용되기 전에 한 번만 수행되며, 이 단계에서 정적 변수의 초기화와 정적 초기화 블록의 실행이 이루어진다.

#### Execution Engine

- 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트코드는 실행 엔진에 의해 실행된다.
- 실행 엔진는 바이트코드를 명령어 단위로 읽어서 실행한다.
- 바이트코드의 각 명령어는 1바이트짜리 OpCode와 추가 피연산자로 이루어져 있으며, 실행 엔진은 하나의 OpCode를 가져와서 피연산자와 함께 작업을 수행한 다음, 다음 OpCode를 수행하는 식으로 동작한다.
- 실앵엔진은 바이트코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경하며, 그 방식은 두 가지가 있다.
    - 인터프리터 : 바이트코드 명령어를 하나씩 읽어서 해석하고 실행한다.
    - JIT 컴파일러 : 인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고, 이후에는 해당 메서드를 더 이상 인터프리팅하지 않고 네이티브 코드로 직접 실행하는
      방식이다.
    - JIT 컴파일러가 컴파일하는 과정은 바이트코드를 하나씩 인터프리팅하는 것보다 훨씬 오래 걸리므로, 만약 한 번만 실행되는 코드라면 컴파일하지 않고 인터프리팅하는 것이 훨씬 유리하다. 따라서, JIT
      컴파일러를 사용하는 JVM들은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을 때에만 컴파일을 수행한다.
- JIT 컴파일러는 바이트코드를 일단 중간 단계의 표현인 IR(Intermediate Representation)로 변환하여 최적화를 수행하고 그 다음에 네이티브 코드를 생성한다.
- 실행 엔진이 어떻게 동작하는지는 JVM 명세에 규정되지 않았다. JVM 벤더들의 다양한 기법으로 실행 엔진을 향상 시키고 다양한 방식의 JIT 컴파일러를 도입한다.

#### Garbage Collection

- GC(가비지 컬렉터)는 애플리케이션의 동적 메모리 할당 요청을 자동으로 관리합니다.
- GC는 다음과 같은 작업으로 자동 동적 메모리 관리를 수행한다.
    - 운영 체제에 메모리를 할당하고 다시 제공한다.
    - 애플리케이션이 요청할 때 해당 메모리를 애플리케이션에 전달한다.
    - 해당 메모리의 어느 부분이 애플리케이션에서 아직 사용되고 있는지 확인한다.
    - 애플리케이션에서 재사용할 수 있도록 사용되지 않은 메모리를 회수합니다.

##### Generational Garbage Collection

- 이론상 가장 간단한 GC 알고리즘은 실행될 때마다 모든 객체를 반복한다. 이때 남은 객체는 모두 가비지로 간주하기 때문에 소요되는 시간이 살아있는 객체 수에 비례하게 되어 비효율적이다.
- generational collection을 활용하여 대부분의 어플리케이션에서 경험적으로 관찰된 여러 속성을 활용하여 가비지 객체를 회수하는데 필요한 작업을 최소화한다.
- 관찰된 특성은 약한 세대 가설로, 대부분의 객체가 짧은 시간 동안만 생존한다는 것을 나타낸다.

##### Generation

- 최적화를 위해 메모리는 세대별로 관리 된다. 가비지 수집은 세대가 가득 차면 각 세대에서 발생한다. 가비지 수집은 세대가 가득 차면 각 세대에서 발생한다.
- 대부분의 객체는 young generation 전용 풀에 할당되며 대부분의 객체는 여기서 죽는다.
- young generation이 가득차면 young generation만 모으는 minor collection이 발생하고, 다른 세대의 가비지는 회수되지 않는다. 이러한 컬렉션의 비용은 수집되는 살아있는 객체의
  수에 비례한다.
- 죽은 객체로 가득 찬 young generation은 매우 빠르게 수집된다.
- 일반적으로 각 minor collection동안 young generation에서 생존한 일부 객체들은 Old Generation으로 이동된다.
- 결국 Old Generation가 가득 차고, Major colleation이 발생하여 전체 힙이 수집된다.
- Major collection은 minor collection보다 훨씬 오래 걸린다. 왜냐ㅑ하면 훨씬 더 많은 객체가 관련되기 때문이다.  
  ![image](https://docs.oracle.com/en/java/javase/17/gctuning/img/jsgct_dt_001_armgnt_gn_new.png)
- 일반적으로 Java HotSpot VM은 시작할 때 전체 자바 힙을 주소 공간에 예약하지만, 필요할 때까지 실제 메모리는 할당하지 않는다. 전체 주소 공간은 논리적으로 young generation 과 old
  generation으로 나뉘어진다.
- young generation은 Eden과 두 개의 Survivor 공간으로 구성된다. 대부분의 객체는 처음에는 Eden에 할당된다.
- 어느 한 순간에 하나의 Survivor 은 비어 있으며, 가비지 컬렉션 동안 Eden과 다른 Survivor 공간의 살아있는 객체들이 이동되는 목적지가 된다.
- 가비지 컬렉션 후에는 Eden과 출발지 Suvivor은 비어있다.
- 다음 가비지 컬렉션에서, 두 Suvivor 공간의 목적이 교환된다. 최근에 채워진 공간은 다른 생존공간으로 복사되는 살아있는 객체들의 출처가 된다.
- 객체들은 이런 식으로 생존 공간 사이를 복사되다가, 특정 획수만큼 복사되었거나 공간이 충분하지 않을 때, Old generation 영역으로 복사된다.
- 이 과정을 노화(aging)이라 한다.

[//]: # (##### 가비지 수집 성능에 영향을 미치는 4가지 요소)

##### 가비지 컬렉터 종류

지금까지 위에서 논의한 내용들은 직렬 수집기에 관한 것이다.

- Serial Collector
    - 직렬 수집기는 모든 가비지 컬렉션 작업을 수행하기 위해 단일 스레드를 사용한다. 이는 스레드 간의 통신 오버헤드가 없기 때문에 상대적으로 효율적이다.
    - 이 방식은 단일 프로세서 기계에 적합하다. 왜냐하면 멀티프로세서 하드웨어의 이점을 활용할 수 없기 때문이다. 그러나 데이터 세트가 작은 경우 (100MB까지) 멀티프로세서에서도 유용할 수 있다.
    - Serial Collector는 특정 하드웨어 및 운영 시스템 구성에서 기본적으로 선택되거나, `-XX:+UseSerialGC` 옵션을 사용하여 명시적으로 활성화할 수 있다.
- Parallel Collector
    - 병렬 수집기는 처리량 수집기(Throughput Collector)라고도 알려져 있으며, 직렬 수집기와 유사한 세대별 수집기이다.
    - 직렬 수집기와 병렬 수집기의 차이점은 병렬 수집기가 가비지 컬렉션 속도를 높이기 위해 여러 스레드를 사용한다는 것이다.
    - 병렬 수집기는 중간 크기에서 큰 크기의 데이터 세트를 가진 애플리케이션에 적합하며, 멀티프로세서 또는 멀티스레드 하드웨어에서 실행된다. `-XX:+UseParallelGC` 옵션을 사용하여 활성화할 수
      있다.
    - 병렬 압축(Parallel Compaction)은 병렬 수집기가 주요 수집을 병렬로 수행할 수 있도록 하는 기능이다.
    - 병렬 압축 없이는 주요 수집이 단일 스레드를 사용하여 수행되며, 이는 확장성을 크게 제한할 수 있다. `-XX:+UseParallelGC` 옵션이 지정된 경우 병렬 압축은 기본적으로 활성화된다. 병렬
      압축을 비활성화하려면 `-XX:-UseParallelOldGC` 옵션을 사용하면 됩니다.
- Garbage-First Garbage Collector
    - G1 Garbage Collector는 애플리케이션에 대해 비용이 많이 드는 작업을 동시에 수행하는 주로 동시적인 수집기이다.
    - 이 수집기는 소규모 기계부터 대용량 메모리를 갖춘 대형 다중프로세서 기계까지 확장 가능하게 설계되었다.
    - 높은 확률로 짧은 pause-time 목표를 충족시키면서 높은 처리량을 달성할 수 있는 능력을 제공한다. Stop-The-World 현상을 최소화한다.
    - G1은 대부분의 하드웨어 및 운영 체제 구성에서 기본적으로 선택되거나 `-XX:+UseG1GC` 옵션을 사용하여 명시적으로 활성화할 수 있다.
    - JDK 7부터 사용 가능한 방식, JDK 9 부터 Default로 설정되어 있다.
- The Z Garbage Collector
    - Z 가비지 컬렉터는 확장성이 높고 지연시간이 낮은 가비지 컬렉터이다.
    - ZGC는 애플리케이션의 실행을 멈추지 않고 모든 고비용 작업을 동시에 수행한다.
    - ZGC는 몇 밀리초의 최대 정지 시간을 제공하지만, 일부 처리량 손실이 발생할 수 있다. ZGC는 낮은 지연 시간이 필요한 애플리케이션을 위해 설계되었다.
    - 정지 시간은 사용되는 힙 크기에 관계없이 독립적이다. ZGC는 8MB에서 16TB에 이르는 힙 크기를 지원합니다. 이를 활성화하기 위해서는` -XX:+UseZGC` 옵션을 사용하면 된다.
    - JDK 11에서 실험적으로 추가되었고 JDK 15부터 정식 수집기로 인정되었다.


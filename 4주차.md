- JSP - 14,18,19
- Spring 기준으로 면접 준비
- 관계형 DB 학습
    - Lock, MVCC
    - MySQL, MariaDB, PostgreSQL ( + AWS aurora DB )
    - DB 정규화

# 참고 문서

- [Spring Boot Roadmaps](https://roadmap.sh/spring-boot)
- [Spring framework core](https://docs.spring.io/spring-framework/reference/core.html)
- [Spring Web Mvc Framework](https://www.tutorialspoint.com/spring/spring_web_mvc_framework.htm)

# Spring

## Spring Core

### IoC(Inversion of Control)

#### 정의

객체의 생명주기와 의존성 관리를 개발자가 아닌 컨테이너나 프레임워크가 담당하는 설계 원칙, 즉 객체가 자신이 사용할 객체를 직접 생성하거나 관리하지 않고, 외부에서 주입받아 사용한다.

#### 주요 개념

1. 컨테이너(Contatiner)
    - IoC 컨테이너는 객체의 생성, 초기화, 의존성 주입, 소멸 등을 관리한다.
    - Spring에서는 `ApplicationContext`가 대표적인 IoC 컨테이너이다.
2. 빈(Bean)
    - IoC 컨테이너가 관리하는 객체를 빈이라고 한다.
    - Spring에서는 `@Component`, `@Service`, `@Repository`, `@Controller` 등의 어노테이션을 사용하여 빈을 등록한다.
3. 빈 설정(Configuration) - BeanDefinition
    - 빈을 등록하는 방법은 XML, 어노테이션, 자바 설정 클래스 등을 통해 이뤄진다.
    - 이를 통해 IoC 컨테이너가 어떤 객체를 생성하고, 어떻게 의존성을 주입할지 정의한다.

##### BeanFactory vs ApplicationContext

- BeanFactory
    - 스프링 컨테이너의 최상위 인터페이스
    - 스프링 빈을 관리하고 조회하는 역할
    - getBean() 메서드 제공
- ApplicationContext
    - BeanFactory의 하위 인터페이스
    - 그 외에도 MessageSource, ApplicationEventPublisher, EnvironmentCapable, ResourceLoader 인터페이스를 상속받는다.

#### 장점

1. 결합도 감소
    - IoC를 통해 객체 간의 강한 결합을 줄일 수 있다.
    - 객체가 직접 다른 객체를 생성하거나 의존하지 않고, 외부에서 주입받기 때문에 객체 간의 의존성이 낮아진다.
    - 이는 코드의 변경이 필요할 때, 특정 객체만 수정하면 되므로 유지 보수가 용이하다.
2. 유연성 증가
    - IoC를 사용하면 애플리케이션의 구성 요소를 쉽게 교체할 수 있다.
    - 예를 들어, 특정 기능을 구현한 객체를 다른 구현체로 대체할 때, 코드의 변경 없이 설정만 변경하면 된다.
    - 이는 다양한 환경에서 동일한 코드를 사용할 수 있게 해준다.
3. 테스트 용이성
    - IoC를 통해 객체의 의존성을 외부에서 주입받기 때문에, 모의 객체(mock object)를 주입하여 단위 테스트를 쉽게 수행할 수 있다.
    - 이는 테스트 코드 작성 시, 실제 객체 대신 가짜 객체를 사용하여 테스트 환경을 제어할 수 있게 해준다.
4. 중복 코드 감소
    - IoC 컨테이너가 객체의 생성, 초기화, 소멸 등을 관리하기 때문에, 개발자가 이러한 작업을 일일이 처리할 필요가 없다.
    - 이는 중복 코드를 줄이고, 코드의 간결성을 유지할 수 있게 한다.
5. 객체의 생명주기 관리:
    - IoC 컨테이너는 객체의 생명주기를 관리한다.
    - 이는 객체의 생성 시점, 초기화 시점, 소멸 시점을 컨테이너가 제어하여 애플리케이션의 안정성을 높이고, 메모리 관리 등의 부가적인 작업을 자동으로 처리한다.

### DI(Dependency Injection)

#### 정의

객체 간의 의존성을 외부에서 주입해주는 방식.

#### 의존성 주입 방법

1. 생성자 주입 : 생성자를 통해 의존성을 주입받는 방식
    - 객체가 생성될 때 필요한 모든 의존성을 주입해주는 방식
    - 불변 객체를 만들 때 유용
    - 의존성이 명확하게 드러나기 때문에 코드의 가독성이 높아진다
    - `final` 키워드를 사용하여 개발자의 실수를 막을 수 있다.
2. Setter 주입 : Setter 메서드를 통해 의존성을 주입받는 방식
    - 의존성이 선택적일 때 유용
3. 필드 주입 : 필드에 직접 의존성을 주입받는 방식
    - 간단하게 사용할 수 있지만, 테스트와 리팩토링이 어려워지는 단점이 있다.
    - Spring에서는 권장하지 않는 방식이다.
4. 메서드 주입 : 일반 메서드를 통해 의존성을 주입받는 방식
    - 한번에 여러 필드를 주입할 수 있다.
    - 일반적으로 잘 사용하지 않는다.

#### 장점

- 결합도 감소: 객체 간의 강한 결합을 피할 수 있다.
- 유연성 증가: 다양한 구현체를 쉽게 교체할 수 있다.
- 테스트 용이성: 모의 객체(mock)를 주입하여 단위 테스트를 쉽게 할 수 있다.

#### 빈이 여러개 일 때 해결 방법

조회 대상 빈이 2개 이상이 되는 경우 해결하는 방법은 세 가지가 있다.

1. Autowired 필드명 매칭
    - 가장 먼저 타입 매칭을 시도하고 그 결과가 2개 이상이면 필드명으로 빈 이름 매칭을 시도한다.
2. @Qualifier
    - @Qualifier 어노테이션을 사용하여 빈 이름을 지정한다.
    - 빈 이름을 지정하여 의존성을 주입받을 빈을 선택할 수 있다.
    - 메타 어노테이션을 사용하여 커스텀 어노테이션을 활용해도 된다.
3. @Primary
    - @Primary 어노테이션을 사용하여 우선순위를 지정한다.
    - 여러 빈 중 우선적으로 주입받을 빈을 선택할 수 있다.
4. 제네릭 타입 매칭
    - 제네릭 타입을 사용하여 빈을 주입받을 수 있다.
5. 만약 여러 개의 빈을 사용하고 싶을 때
    - List, Map을 사용하여 여러 빈을 주입받을 수 있다.

### Spring Bean Scope

#### 정의

컨테이너가 빈의 생명주기를 어떻게 관리할지 정의 하는 것

#### 종류

1. Singleton
    - 기본 스코프
    - Spring IoC 컨테이너당 하나의 빈 인스턴스만 생성하고, 모든 요청에 같은 인스턴스를 반환한다.
    - 싱글턴을 보장하기 위해 CGLIB 라이브러리를 사용한다.
2. Prototype
    - 빈 요청 시마다 새로운 인스턴스를 생성한다.
    - 상태가 있는 빈이나 매번 다른 객체가 필요할 때 유용하다.
    - 스프링 컨테이너는 프로토타입 빈의 생성, 의존관계 주입, 초기화까지만 관여한다.
    - `@PreDestroy` 같은 종료 메서드가 호출되지 않는다.
    - 싱글톤 빈과 함께 사용하게 되면 문제가 생길 수 있다. (싱글톤 빈이 프로토타입 빈을 참조할 때)
        - ObjectFactory, ObjectProvider, JSR-330 Provider를 사용하여 해결할 수 있다.
3. Request Scope
    - HTTP 요청마다 하나의 빈 인스턴스를 생성한다.
    - 각 요청에 대해 별도의 빈 인스턴스가 필요할 때 유용하다.
4. Session Scope
    - HTTP 세션마다 새로운 빈 인스턴스를 생성한다.
    - 사용자가 세션 동안 동일한 빈 인스턴스를 사용할 때 유용하다.
5. Application Scope
    - 서블릿 컨텍스트 당 하나의 빈 인스턴스를 생성한다.
    - 애플리케이션 내의 모든 요청에서 동일한 인스턴스를 사용할 때 유용하다.
6. WebSocket Scope
    - WebSocket 세션마다 새로운 빈 인스턴스를 생성한다.
    - WebSocket 연결 동안 동일한 빈 인스턴스를 사용할 때 유용하다.

##### proxyMode

싱글턴 빈이 Request, Session Scope 빈을 주입 받을 때 발생하는 문제를 해결하기 위해 사용한다.  
프록시 객체가 대신 주입되어 실제 빈을 대신 호출한다.  
프록시 객체의 동작은 싱글턴 빈처럼 동작하고 위임하는 로직만 있다.

- ScopedProxyMode
    - INTERFACES: JDK 동적 프록시를 사용
    - TARGET_CLASS: CGLIB를 사용
    - NO: 프록시를 사용하지 않음
    - DEFAULT: 기본 설정을 사용

### Spring AOP



> @EnableLoadTimeWeaving

## Spring Mvc

### Servlet

#### 정의

서블릿은 클라이언트(주로 웹 브라우저)의 요청을 처리하고, 동적 콘텐츠를 생성하여 응답하는 자바 클래스를 의미한다.

#### 서블릿의 주요 개념

1. 서블릿 컨테이너(Servlet Container)
    - 서블릿을 실행하고 관리하는 역할을 한다.
    - 대표적인 서블릿 컨테이너로는 Apache Tomcat, Jetty 등이 있다.
    - 주요 역할
        - 서블릿 인스턴스 생성 및 초기화
        - 클라이언트 요청을 서블릿에 전달
        - 서블릿 응답을 클라이언트로 전송
        - 서블릿의 생명주기 관리
2. 서블릿 생명주기(Servlet Life Cycle)
    - 생성: 서블릿 컨테이너가 서블릿을 처음 로드할 때, 서블릿 클래스의 인스턴스를 생성한다.
    - 초기화: 서블릿 컨테이너는 init() 메서드를 호출하여 서블릿을 초기화한다. 이 메서드는 서블릿이 생성된 후 한 번만 호출된다.
    - 서비스: 클라이언트 요청이 있을 때마다 서블릿 컨테이너는 service() 메서드를 호출한다. 이 메서드는 요청을 처리하고, 응답을 생성하는 역할을 한다. service() 메서드는 HTTP 요청 메서드(GET, POST 등)에 따라 doGet(), doPost() 등의 메서드를 호출한다.
    - 소멸: 서블릿 컨테이너가 서블릿을 언로드하거나 종료할 때 destroy() 메서드를 호출하여 서블릿을 소멸시킨다.
3. HTTP 요청 및 응답 처리
   - HTTP 요청을 처리하기 위해 HttpServletRequest 객체를 사용하고, HTTP 응답을 생성하기 위해 HttpServletResponse 객체를 사용한다.

#### 서블릿과 Spring MVC의 관계
Spring MVC는 서블릿을 기반으로 하는 웹 프레임워크이다.  
Spring MVC는 DispatcherServlet이라는 특수한 서블릿을 사용하여 모든 HTTP 요청을 중앙에서 처리한다.(like Front Controller pattern)  
DispatcherServlet은 요청을 적절한 컨트롤러로 라우팅하고, 컨트롤러가 처리한 결과를 뷰로 전달한다.

### MVC 패턴
MVC 패턴이 등장하기 이전에는 하나의 서블릿 또는 JSP 파일에서 모든 로직을 처리하였다. (뷰 랜더링, 비즈니스 로직, 데이터베이스 접근 등)  
이는 유지보수가 어렵고, 확장성이 떨어지는 문제가 있었다. 이로 인해 MVC 패턴이 등장하게 되었다.   
MVC 패턴은 애플리케이션을 Model, View, Controller로 구분하여 각 역할을 분리하는 패턴이다.  

- Controller: HTTP 요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행한다. 그리고 View에 전달할 결과 데이터를 조회해서 Model에 담는다.
- Model: View에 출력할 데이터를 담아둔다. View가 필요한 데이터를 모두 모델에 담아서 전달해주는 덕분에 뷰는 비즈니스 로직이나 데이터 접근을 몰라도 되고, 화면을 렌더링 하는 일에 집중할 수 있다.
- View: Model에 담겨있는 데이터를 사용해서 화면을 그리는 일에 집중한다. 여기서는 HTML을 생성하는 부분을 말한다.

#### MVC model 1, model 2

#### 

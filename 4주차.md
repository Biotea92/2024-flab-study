
# Spring

## Spring Core

### IoC(Inversion of Control)

#### 정의

객체의 생명주기와 의존성 관리를 개발자가 아닌 컨테이너나 프레임워크가 담당하는 설계 원칙, 즉 객체가 자신이 사용할 객체를 직접 생성하거나 관리하지 않고, 외부에서 주입받아 사용한다.

#### 주요 개념

1. 컨테이너(Contatiner)
    - IoC 컨테이너는 객체의 생성, 초기화, 의존성 주입, 소멸 등을 관리한다.
    - Spring에서는 `ApplicationContext`가 대표적인 IoC 컨테이너이다.
2. 빈(Bean)
    - IoC 컨테이너가 관리하는 객체를 빈이라고 한다.
    - Spring에서는 `@Component`, `@Service`, `@Repository`, `@Controller` 등의 어노테이션을 사용하여 빈을 등록한다.
3. 빈 설정(Configuration) - BeanDefinition
    - 빈을 등록하는 방법은 XML, 어노테이션, 자바 설정 클래스 등을 통해 이뤄진다.
    - 이를 통해 IoC 컨테이너가 어떤 객체를 생성하고, 어떻게 의존성을 주입할지 정의한다.

##### BeanFactory vs ApplicationContext

- BeanFactory
    - 스프링 컨테이너의 최상위 인터페이스
    - 스프링 빈을 관리하고 조회하는 역할
    - getBean() 메서드 제공
- ApplicationContext
    - BeanFactory의 하위 인터페이스
    - 그 외에도 MessageSource, ApplicationEventPublisher, EnvironmentCapable, ResourceLoader 인터페이스를 상속받는다.

#### 장점

1. 결합도 감소
    - IoC를 통해 객체 간의 강한 결합을 줄일 수 있다.
    - 객체가 직접 다른 객체를 생성하거나 의존하지 않고, 외부에서 주입받기 때문에 객체 간의 의존성이 낮아진다.
    - 이는 코드의 변경이 필요할 때, 특정 객체만 수정하면 되므로 유지 보수가 용이하다.
2. 유연성 증가
    - IoC를 사용하면 애플리케이션의 구성 요소를 쉽게 교체할 수 있다.
    - 예를 들어, 특정 기능을 구현한 객체를 다른 구현체로 대체할 때, 코드의 변경 없이 설정만 변경하면 된다.
    - 이는 다양한 환경에서 동일한 코드를 사용할 수 있게 해준다.
3. 테스트 용이성
    - IoC를 통해 객체의 의존성을 외부에서 주입받기 때문에, 모의 객체(mock object)를 주입하여 단위 테스트를 쉽게 수행할 수 있다.
    - 이는 테스트 코드 작성 시, 실제 객체 대신 가짜 객체를 사용하여 테스트 환경을 제어할 수 있게 해준다.
4. 중복 코드 감소
    - IoC 컨테이너가 객체의 생성, 초기화, 소멸 등을 관리하기 때문에, 개발자가 이러한 작업을 일일이 처리할 필요가 없다.
    - 이는 중복 코드를 줄이고, 코드의 간결성을 유지할 수 있게 한다.
5. 객체의 생명주기 관리:
    - IoC 컨테이너는 객체의 생명주기를 관리한다.
    - 이는 객체의 생성 시점, 초기화 시점, 소멸 시점을 컨테이너가 제어하여 애플리케이션의 안정성을 높이고, 메모리 관리 등의 부가적인 작업을 자동으로 처리한다.

#### 단점 

1. 성능 오버헤드
   - IoC 컨테이너는 런타임에 객체의 생성, 의존성 주입, 생명주기 관리 등을 처리하기 때문에 성능에 영향을 줄 수 있다.
   - 많은 수의 빈을 초기화하거나 복잡한 의존성 주입(순환 의존성, 조건부 의존성)을 수행할 때 특히 증가 할 수 있다.
   - 런타임 단계에서 처리를 하기 때문에 컴파일 단계에서 오류를 발견하기 어렵다.
2. 복잡성 증가
   - 설정파일, 어노테이션 등을 많은 빈을 등록하면 어디에서 빈이 정의되는지 어떻게 주입되는지 파악하기 어려울 수 있다.
   - 이로 인해 특정 빈이 올바르게 주입되지 않거나 초기화되지 않는 경우 디버깅이 어려울 수 있다.
   - 개발자들간의 약속을 하거나 문서화를 통해 이러한 문제를 해결할 수 있다. ex) 생성자 주입 사용, layer 분리 등


### DI(Dependency Injection)

#### 정의

객체 간의 의존성을 외부에서 주입해주는 방식.

#### 의존성 주입 방법

1. 생성자 주입 : 생성자를 통해 의존성을 주입받는 방식
    - 객체가 생성될 때 필요한 모든 의존성을 주입해주는 방식
    - 불변 객체를 만들 때 유용
    - 의존성이 명확하게 드러나기 때문에 코드의 가독성이 높아진다
    - `final` 키워드를 사용하여 개발자의 실수를 막을 수 있다.
2. Setter 주입 : Setter 메서드를 통해 의존성을 주입받는 방식
    - 의존성이 선택적일 때 유용
3. 필드 주입 : 필드에 직접 의존성을 주입받는 방식
    - 간단하게 사용할 수 있지만, 테스트와 리팩토링이 어려워지는 단점이 있다.
    - Spring에서는 권장하지 않는 방식이다.
4. 메서드 주입 : 일반 메서드를 통해 의존성을 주입받는 방식
    - 한번에 여러 필드를 주입할 수 있다.
    - 일반적으로 잘 사용하지 않는다.

#### 장점

- 결합도 감소: 객체 간의 강한 결합을 피할 수 있다.
- 유연성 증가: 다양한 구현체를 쉽게 교체할 수 있다.
- 테스트 용이성: 모의 객체(mock)를 주입하여 단위 테스트를 쉽게 할 수 있다.

#### 빈이 여러개 일 때 해결 방법

조회 대상 빈이 2개 이상이 되는 경우 해결하는 방법은 세 가지가 있다.

1. Autowired 필드명 매칭
    - 가장 먼저 타입 매칭을 시도하고 그 결과가 2개 이상이면 필드명으로 빈 이름 매칭을 시도한다.
2. @Qualifier
    - @Qualifier 어노테이션을 사용하여 빈 이름을 지정한다.
    - 빈 이름을 지정하여 의존성을 주입받을 빈을 선택할 수 있다.
    - 메타 어노테이션을 사용하여 커스텀 어노테이션을 활용해도 된다.
3. @Primary
    - @Primary 어노테이션을 사용하여 우선순위를 지정한다.
    - 여러 빈 중 우선적으로 주입받을 빈을 선택할 수 있다.
4. 제네릭 타입 매칭
    - 제네릭 타입을 사용하여 빈을 주입받을 수 있다.
5. 만약 여러 개의 빈을 사용하고 싶을 때
    - List, Map을 사용하여 여러 빈을 주입받을 수 있다.

##### 조회 대상 빈이 2개 이상일 경우 사례 
1. Profile 설정 
   - `@Profile` 어노테이션을 사용하여 환경별로 다른 빈을 등록 하는 경우 
   - 개발환경, 테스트환경, 프로덕션환경 등에 따라 빈 구성을 달리 할 수 있다. 
2. 인터페이스의 다양한 구현체를 이용
   - 예를 들어 oauth2 클라이언트를 구현할 때, 구글, 네이버, 카카오 등 다양한 인터페이스를 구현할 수 있다.
   - 필요에 따라 다양한 구현체를 주입받아 사용할 수 있다.
3. 다중 데이터 소스 설정
   - 예를 들어 읽기 전용 데이터베이스와 쓰기 전용 데이터베이스를 분리하여 사용할 때, 다중 데이터 소스를 설정할 수 있다.

### Spring Bean Scope

#### 정의

컨테이너가 빈의 생명주기를 어떻게 관리할지 정의 하는 것

#### 종류

1. Singleton
    - 기본 스코프
    - Spring IoC 컨테이너당 하나의 빈 인스턴스만 생성하고, 모든 요청에 같은 인스턴스를 반환한다.
    - 싱글턴을 보장하기 위해 CGLIB 라이브러리를 사용한다.
2. Prototype
    - 빈 요청 시마다 새로운 인스턴스를 생성한다.
    - 상태가 있는 빈이나 매번 다른 객체가 필요할 때 유용하다.
    - 스프링 컨테이너는 프로토타입 빈의 생성, 의존관계 주입, 초기화까지만 관여한다.
    - `@PreDestroy` 같은 종료 메서드가 호출되지 않는다.
    - 싱글톤 빈과 함께 사용하게 되면 문제가 생길 수 있다. (싱글톤 빈이 프로토타입 빈을 참조할 때)
        - ObjectFactory, ObjectProvider, JSR-330 Provider를 사용하여 해결할 수 있다.
3. Request Scope
    - HTTP 요청마다 하나의 빈 인스턴스를 생성한다.
    - 각 요청에 대해 별도의 빈 인스턴스가 필요할 때 유용하다.
4. Session Scope
    - HTTP 세션마다 새로운 빈 인스턴스를 생성한다.
    - 사용자가 세션 동안 동일한 빈 인스턴스를 사용할 때 유용하다.
5. Application Scope
    - 서블릿 컨텍스트 당 하나의 빈 인스턴스를 생성한다.
    - 애플리케이션 내의 모든 요청에서 동일한 인스턴스를 사용할 때 유용하다.
6. WebSocket Scope
    - WebSocket 세션마다 새로운 빈 인스턴스를 생성한다.
    - WebSocket 연결 동안 동일한 빈 인스턴스를 사용할 때 유용하다.

##### proxyMode

싱글턴 빈이 Request, Session Scope 빈을 주입 받을 때 발생하는 문제를 해결하기 위해 사용한다.  
프록시 객체가 대신 주입되어 실제 빈을 대신 호출한다.  
프록시 객체의 동작은 싱글턴 빈처럼 동작하고 위임하는 로직만 있다.

- ScopedProxyMode
    - INTERFACES: JDK 동적 프록시를 사용
    - TARGET_CLASS: CGLIB를 사용
    - NO: 프록시를 사용하지 않음
    - DEFAULT: 기본 설정을 사용

##### 싱글톤 생성 방법 
싱글톤을 생성하는 방법은 많지만 동시성 문제와 성능을 고려해서 사용해야 한다.  

가장 좋은 방법은 Enum을 사용하거나 LazyHolder 방식을 사용하는 것이다.

- Enum 방식
     - Enum은 싱글톤이 보장된다.
     - Enum은 직렬화가 가능하다.
     - Reflection을 통한 공격에 안전하다.
```Java
public enum Elvis {
    INSTANCE;
}
```
- LazyHolder 방식
     - LazyHolder 클래스를 로딩하면서 LazyHolderSingleton 인스턴스를 생성한다.
     - holder 안에 선언된 LazyHolderSingleton 인스턴스는 static이기 때문에 클래스 로딩 시점에 한 번만 초기화된다.
```Java
public class LazyHolderSingleton {

    private LazyHolderSingleton() {
    }

    public static LazyHolderSingleton getInstance() {
        return LazyHolder.uniqueInstance;
    }

    private static class LazyHolder {
        private static final LazyHolderSingleton uniqueInstance = new LazyHolderSingleton();
    }
}
```

### Spring AOP

#### JDK Dynamic Proxy vs CGLIB
프록시 객체를 생성하는 방법이다.  

##### JDK Dynamic Proxy
- Java의 reflection을 사용하여 런타임에 동적으로 프록시 객체를 생성한다.  
- 인터페이스를 구현한 클래스에 대해서만 프록시 객체를 생성할 수 있다.
- InvocationHandler 인터페이스를 구현하여 프록시 객체를 생성한다.

###### 장점 
- 표준라이브러리를 사용한다.
###### 단점
- 인터페이스가 필요하다. 
- 리플렉션을 사용하기 때문에 성능이 떨어진다.

##### CGLIB
- 바이트코드 조작을 통해 런타임에 동적으로 프록시 클래스를 생성하는 오픈소스 라이브러리이다. 
- 구체 클래스를 상속받아 프록시 객체를 생성한다.
- 메서드를 오버라이드하여, 호출 전후에 추가 로직을 넣는다. 

###### 장점
- 인터페이스가 없어도 프록시 객체를 생성할 수 있다.
- 바이트코드 조작을 통해 강력한 기능을 제공한다.

###### 단점
- 바이트코드 조작으로 인해 복잡도가 증가한다.
- 외부 라이브러리에 의존한다.

> @EnableLoadTimeWeaving

## Spring Mvc

### Servlet

#### 정의

서블릿은 클라이언트(주로 웹 브라우저)의 요청을 처리하고, 동적 콘텐츠를 생성하여 응답하는 자바 클래스를 의미한다.

#### 서블릿의 주요 개념

1. 서블릿 컨테이너(Servlet Container)
    - 서블릿을 실행하고 관리하는 역할을 한다.
    - 대표적인 서블릿 컨테이너로는 Apache Tomcat, Jetty 등이 있다.
    - 주요 역할
        - 서블릿 인스턴스 생성 및 초기화
        - 클라이언트 요청을 서블릿에 전달
        - 서블릿 응답을 클라이언트로 전송
        - 서블릿의 생명주기 관리
2. 서블릿 생명주기(Servlet Life Cycle)
    - 생성: 서블릿 컨테이너가 서블릿을 처음 로드할 때, 서블릿 클래스의 인스턴스를 생성한다.
    - 초기화: 서블릿 컨테이너는 init() 메서드를 호출하여 서블릿을 초기화한다. 이 메서드는 서블릿이 생성된 후 한 번만 호출된다.
    - 서비스: 클라이언트 요청이 있을 때마다 서블릿 컨테이너는 service() 메서드를 호출한다. 이 메서드는 요청을 처리하고, 응답을 생성하는 역할을 한다. service() 메서드는 HTTP 요청 메서드(GET, POST 등)에 따라 doGet(), doPost() 등의 메서드를 호출한다.
    - 소멸: 서블릿 컨테이너가 서블릿을 언로드하거나 종료할 때 destroy() 메서드를 호출하여 서블릿을 소멸시킨다.
3. HTTP 요청 및 응답 처리
   - HTTP 요청을 처리하기 위해 HttpServletRequest 객체를 사용하고, HTTP 응답을 생성하기 위해 HttpServletResponse 객체를 사용한다.

#### 서블릿과 Spring MVC의 관계
Spring MVC는 서블릿을 기반으로 하는 웹 프레임워크이다.  
Spring MVC는 DispatcherServlet이라는 특수한 서블릿을 사용하여 모든 HTTP 요청을 중앙에서 처리한다.(like Front Controller pattern)  
DispatcherServlet은 요청을 적절한 컨트롤러로 라우팅하고, 컨트롤러가 처리한 결과를 뷰로 전달한다.

### MVC 패턴
MVC 패턴이 등장하기 이전에는 하나의 서블릿 또는 JSP 파일에서 모든 로직을 처리하였다. (뷰 랜더링, 비즈니스 로직, 데이터베이스 접근 등)  
이는 유지보수가 어렵고, 확장성이 떨어지는 문제가 있었다. 이로 인해 MVC 패턴이 등장하게 되었다.   
MVC 패턴은 애플리케이션을 Model, View, Controller로 구분하여 각 역할을 분리하는 패턴이다.  

- Controller: HTTP 요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행한다. 그리고 View에 전달할 결과 데이터를 조회해서 Model에 담는다.
- Model: View에 출력할 데이터를 담아둔다. View가 필요한 데이터를 모두 모델에 담아서 전달해주는 덕분에 뷰는 비즈니스 로직이나 데이터 접근을 몰라도 되고, 화면을 렌더링 하는 일에 집중할 수 있다.
- View: Model에 담겨있는 데이터를 사용해서 화면을 그리는 일에 집중한다. 여기서는 HTML을 생성하는 부분을 말한다.

#### MVC 패턴의 장점
1. 유지보수성 증가: 각 역할이 분리되어 있기 때문에 코드 변경이 발생했을 때, 해당 부분만 수정하면 된다. UI가 변경되더라도 비즈니스 로직을 수정할 필요가 없다.
2. 확장성 증가: 각 역할이 분리되어 있기 때문에 새로운 기능을 추가하거나 변경할 때, 다른 부분에 영향을 주지 않는다.
3. 재사용성 증가: 동일한 비즈니스 로직을 여러 뷰에서 사용할 수 있다.

#### MVC 패턴의 단점
1. 복잡성 증가 
    - 초기 설계 단계에서 MVC 각각을 분리하는 것이 복잡할 수 있다. 
    - Model과 View 사이에서 데이터 바인딩과 관련해서 추가작업이 필요할 수 있다.

#### MVVM(Model-View-ViewModel) 패턴 
주로 모바일에서 사용되는 패턴으로 ViewModel이 추가된 패턴이다.

- Model: 데이터와 비즈니스 로직을 담당한다. 데이터의 상태를 저장하고 변경하는 역할을 하며, 데이터 변경 시 알림을 제공한다.
- View: 사용자에게 보여지는 화면을 담당한다. 뷰는 뷰모델을 관찰하고 데이터 바인딩을 통해 자동으로 업데이트한다.
- ViewModel: 뷰와 모델 사이의 중재자 역할로 모델의 데이터를 변환하여 뷰에 랜더링하고, 뷰에서 발생하는 이벤트를 처리하여 모델을 업데이트한다. 데이터 바인딩을 통해 뷰와 데이터를 동기화한다.

#### model 1, model 2 [JavaServerTM PagesTM - Specification 0.92, 1998](https://www.kirkdorffer.com/jspspecs/jsp092.html#model)

##### Model 1

![mvc Model1.png](/img/mvc%20Model1.png)

- model1은 JSP 파일 하나에 모든 로직을 처리하는 방식이다.

##### Model 2

![mvc Model2.png](/img/mvc Model2.png)

1. model2는 웹 브라우저의 요청을 하나의 서블릿이 받는다. 
2. 서블릿은 웹 브라우저의 요청을 알맞게 처리한 후 그 결과를 보여줄 JSP로 포워딩한다. 
3. 포워딩을 통해 요청 흐름을 받은 JSP 페이지는 결과 화면을 클라이언트에 전송한다. 

#### Spring Web MVC 

Spring MVC는 중앙 서블릿인 DispatcherServlet이 요청처리를 담당하는 Front Controller 패턴을 사용한다.

##### 컨텍스트 계층

![DispathcherServlet.png](/img/DispatcherServlet.png)

1. DispatcherServlet
   - 모든 HTTP 요청을 중앙에서 처리하는 프론트 컨트롤러이다. 
   - 클라이언트의 요청을 받아 적절한 핸들러로 라우팅하고, 결과를 뷰로 전달한다.
   - `web.xml` 파일이나 Java Config에서 설정한다. 
2. Servlet WebApplicationContext
   - DispatcherServlet이 사용하는 컨텍스트이다.
   - DispatcherServlet 인스턴스는 고유한 WebApplicationContext를 가진다.
   - 구성 요소
     - Controller: 사용자 요청을 처리하고, 응답을 생성한다.
     - ViewResolver: 논리적인 뷰 이름을 실제 뷰로 변환한다.
     - HandlerMapping: 요청 URL을 처리할 핸들러를 찾는다. 
3. Root WebApplicationContext
   - 애플리케이션 전체에서 공통으로 사용되는 빈을 정의한다. 
   - 구성 요소
     - Service, Repository 등

##### 처리 과정(공식 문서 기준)

1. WebApplicationContext 조회 및 바인딩 
   - 요청의 속성으로 바인딩되어, 컨트롤러 및 프로세스의 다른 요소들이 사용할 수 있도록 한다. 
   - 기본적으로 DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE 키로 바인딩된다.
2. locale resolver 바인딩 
   - 요청을 처리할 때 사용할 로케일을 결정하기 위해 로케일 리졸버가 요청에 바인딩된다. 
   - 뷰 렌더링, 데이터 준비 등에 사용되며 만약 로케일 리졸빙이 필요하지 않다면 무시해도 된다.
3. theme resolver 바인딩
   - 뷰와 같은 요소들이 사용할 테마를 결정하기 위해 테마 리졸버가 요청에 바인딩된다. 
   - 테마를 사용하지 않는다면 무시해도 된다.
4. multipart file resolver 
   - 멀티파트 파일 리졸버를 지정하면 요청이 멀티파트인지 검사한다. 
   - 멀티파트가 발견되면, 요청이 `MultipartHttpServletRequest`로 래핑되어 다른 요소들이 이를 처리할 수 있도록 한다. 
5. 적절한 handler 검색
   - 요청을 처리할 적절한 핸들러를 검색한다. 
   - 핸들러가 발견되면, 핸들러와 연관된 실행 체인(전처리기, 후처리기, 컨트롤러)을 실행하여 뷰를 렌더링하기 위한 모델을 준비한다. 
   - 주석 기반 컨트롤러의 경우, `HandlerAdapter` 내에서 응답을 랜더링하여 뷰를 반환하지 않을 수도 있다.
6. 모델 반환 및 뷰 렌더링
   - 모델이 반환되면, 뷰가 렌더링된다.
   - 모델이 반환되지 않으면(전처리기나 후처리기가 요청을 가로챈 경우), 뷰는 렌더링되지 않으며 요청은 이미 완료 된 것으로 간주된다.

##### 처리 과정(김영한님 기준)

![spring mvc.png](/img/SpringMvc.png)

1. 핸들러 조회: 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회한다.
2. 핸들러 어댑터 조회: 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.
3. 핸들러 어댑터 실행: 핸들러 어댑터를 실행한다.
4. 핸들러 실행: 핸들러 어댑터가 실제 핸들러를 실행한다.
5. ModelAndView 반환: 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 변환해서 반환한다.
6. viewResolver 호출: 뷰 리졸버를 찾고 실행한다.
   JSP의 경우: InternalResourceViewResolver 가 자동 등록되고, 사용된다.
7. View 반환: 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고, 렌더링 역할을 담당하는 뷰 객체를 반환한다.
   JSP의 경우 InternalResourceView(JstlView) 를 반환하는데, 내부에 forward() 로직이 있다.
8. 뷰 렌더링: 뷰를 통해서 뷰를 렌더링 한다.

## Filter
Servlet Filter는 요청과 응답을 가로채고 처리할 수 있는 기능을 가진다. 

### 주요 개념
1. 요청 및 응답 가로채기
   - 클라이언트의 요청이 서블릿에 도달하기 전에 필터가 요청을 가로채어 처리할 수 있다. 
   - 서블릿이 응답을 클라이언트로 보내기 전에 필터가 응답을 가로채어 처리할 수 있다. 
2. 필터 체인
   - 여러 필터를 체인으로 연결하여 순차적으로 요청과 응답을 처리한다. 
   - 각 필터는 다음 필터 또는 최종 서블릿으로 요청을 전달할 수 있다. 
3. life cycle
   - 필터는 서블릿 컨테이너에 의해 관리되며 특정 생명주기를 가진다. 
   - 애플리케이션 시작 시 초기화되고, 애플리케이션 종료 시 소멸된다.

### javax.servlet.Filter 인터페이스 주요 메서드
1. init(FilterConfig config): 필터가 초기화될때 호출된다.
2. doFilter(ServletRequest request, ServletResponse response, FilterChain chain): 요청을 가로채고 처리하는 메서드이다.
3. destroy(): 필터가 소멸될 때 호출된다.

### 사용처 
1. 인증 및 권한 
2. 로깅 및 감시
3. 데이터 압축 및 데이터 변환
4. 멀티파트 요청 처리

## Spring Interceptor
Spring MVC에서 요청과 응답을 가로채어 추가적인 처리를 할 수 있다. 

### 주요 개념
1. HandlerInterceptor 인터페이스
   - preHandle(): 컨트롤러 실행 전에 호출된다.
   - postHandle(): 컨트롤러 실행 후, 뷰 렌더링 전에 호출된다.
   - afterCompletion(): 뷰 렌더링 후에 호출된다.
2. HandlerInterceptorAdapter 클래스
   - HandlerInterceptor 인터페이스를 구현한 추상 클래스이다.
   - 필요한 메서드만 오버라이딩하여 사용할 수 있다.

### 사용처
1. 인증 및 권한
2. 로깅 및 감시
3. 성능 모니터링
4. 데이터 검증 및 변환
5. 리소스 관리

### Filter vs Interceptor
- 흐름
  - HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤러
- 적용 범위
   - Filter는 서블릿 컨테이너 레벨에서 동작하며, 모든 요청에 대해 작동한다.
   - Interceptor는 Spring MVC 레벨에서 동작하며, 핸들러(컨트롤러)에 매핑된 요청에 대해서만 작동한다.
- 기능 
   - Filter는 요청과 응답을 전역적으로 수정할 수 있다.
   - Interceptor는 주로 컨트롤러 진입 전과 뷰 렌더링 전후에 추가 처리를 수행한다.
- 사용 용도
   - Filter는 인증, 인코딩, 캐싱 등과 같은 전역적인 요청 처리를 위해 사용된다.
   - Interceptor는 로깅, 인증, 성능 모니터링 등과 같은 핸들러 수준의 요청 처리를 위해 사용된다.

# RDB

## MySQL, MariaDB, PostgreSQL ( + AWS aurora DB )
https://techblog.woowahan.com/6550/  
https://aws.amazon.com/ko/compare/the-difference-between-mysql-vs-postgresql/  
https://aws.amazon.com/ko/compare/the-difference-between-mariadb-vs-mysql/

## 정규화 
### 정규화와 비정규화
#### 정규화 
- 데이터베이스 설계에서 중복을 최소화하고 데이터 무결성을 보장하기 위해 데이터를 구조화하는 과정
- 즉 중복을 제거하고, 한 곳에서만 데이터를 관리한다. 
- 하지만 읽을 때는 항상 원본 데이터를 참조해야하기 때문에 읽기 성능이 떨어질 수 있다. 
- 데이터 정합성 유지가 쉽다.

> 데이터 무결성  
> - 데이터의 무결성은 데이터 값이 정확한 상태
> 데이터 정합성
> - 데이터 정합성은 어떤 데이터들이 값이 서로 일치하는 상태

##### 제1 정규화
테이블의 컬럼이 원자값(Atomic Value)을 갖도록 테이블을 분해하는 것 

##### 제2 정규화
제1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것  
완전 함수 종속 : 기본키의 일부가 아닌 다른 컬럼이 기본키의 전체에 종속되는 경우  

- 예시 

| 학번 | 과목 | 강의실  | 학점 |
|------|------|------|----|
| 501 | 수학 | 101호 | 3  |
| 401 | 수학 | 101호 | 3  |
| 501 | 영어 | 102호 | 2  |
| 401 | 영어 | 102호 | 4  |
| 402 | 국어 | 103호 | 3  |

이 테이블의 기본키는 (학번, 과목)이다. (학번, 과목)은 성적을 결정하고 있다.  
하지만 강의실은 과목에 종속되어 있지 않다. 따라서 제2 정규화를 진행해야 한다.  

##### 제3 정규화
제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것  
이행적 종속 : A -> B, B -> C 일 때 A -> C가 성립하는 경우

- 예시

| 학번 | 과목 | 수강료 |
|------|------|----|
| 501 | 수학 | 10000  |
| 401 | 수학 | 10000  |
| 402 | 국어 | 20000  |
| 501 | 영어 | 15000  |

학번 -> 강좌이름 -> 수강료 이기 때문에 이행적 종속이 발생한다.  
만약 501번 학생의 과목이 국어로 변경되면 수강료도 같이 변경되어야 한다.  
따라서 학번 -> 강좌이름, 강좌이름 -> 수강료로 나누어야 한다.  

##### BCNF 정규화
제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것

후보키: 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합이다. 후보키는 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족해야한다.

- 예시 

| 학번 | 과목 | 교수   |
|------|------|------|
| 501 | 수학 | 김 교수 |
| 401 | 수학 | 김 교수 |
| 501 | 영어 | 나 교수   |
| 401 | 영어 | 박 교수   |
| 402 | 국어 | 이 교수   |

이 테이블의 기본키는 (학번, 과목)이다. (학번, 과목)은 교수를 결정하고 있다. 또한 교수는 과목을 결정하고 있다.  
교수가 과목을 결정하는 결정자이기는 하지만 후보키는 아니다. 따라서 BCNF 정규화를 진행해야 한다.


#### 비정규화
- 정규화된 데이터베이스의 성능을 향상시키기 위해 중복을 허용하는 과정
- 즉, 중복으로 저장하여 참조 없이 읽기 때문에 읽기 성능을 향상시킨다.

## 트랜잭션 
락과 트랜잭션은 비슷한 개념 같지만 락은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다.
- 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위
- 격리 수준이라는 것은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨을 의미한다.


### 격리 수준(MySQL 기준)
격리 수준은 크게 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE로 나뉜다.  
DIRTY READ라고도 하는 READ UNCOMMITTED는 일반적인 데이터 베이스에서는 거의 사용하지 않고 SERIALIZABLE은 동시성이 낮아지기 때문에 사용하지 않는다. 

| 격리 수준            | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ |
|------------------|------------|---------------------|--------------|
| READ UNCOMMITTED | O          | O                   | O            |
| READ COMMITTED   | X          | O                   | O            |
| REPEATABLE READ  | X          | X                   | O(InnoDB는 없음 |
| SERIALIZABLE     | X          | X                   | X            |

#### READ UNCOMMITTED
- 각 트랜잭션에서의 변경 내용이 commit, rollback 여부와 상관없이 다른 트랜잭션에서 조회할 수 있다. 
- 이처럼 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데 다른 트랜잭션에서 조회할 수 있는 현상을 Dirty Read라고 한다.

#### READ COMMITTED
- 어떤 트랜잭션에서 데이터를 변경했더라도 commit이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.
- 하나의 데이터를 UPDATE 하면 변경 전 데이터를 언두 로그로 복사한다. 다른 트랜잭션이 조회를 시도하면 언두 로그를 확인하여 변경 전 데이터를 조회한다.
- 이후 커밋하면 다른 트랙잭션에서도 변경된 데이터를 조회할 수 있다.
- 하나의 트랜잭션에서 똑같은 SELECT 쿼리를 실행했을 때는 결과가 다를 수 있다. 이를 Non-Repeatable Read라고 한다.
- Non-Repeatable Read는 일반적인 상황에서는 문제되지 않을 수 있지만 금전 거래와 같은 상황에서는 문제가 될 수 있다. 
- 예를 들어 다른 트랜잭션에서 입출금이 반복되는 상황에서 다른 트랜잭션에서는 오늘 입금된 총액을 계산하는 SELECT 쿼리는 실행 될 때마다 다른 결과를 가져온다. 

#### REPEATABLE READ
- MySQL InnoDB의 기본 격리 수준이다. 
- InnoDB에서는 트랙잭션이 ROLLBACK될 가능성을 대비해 변경되기 전 레코드를 언두로그에 백업해주고 실제 레코드값을 변경한다. 이러한 변경 방식을 MVCC라고 한다. 
- 사실 READ COMMITTED도 MVCC를 이용해 commit되기 이전의 데이터를 보여주지만 REPEATABLE READ와 READ COMMITTED의 차이는 언두로그에 백업된 레코드의 여러 버전 가운데 어떤 버전을 보여줄 것인가이다.
- REPEATABLE READ에서도 PHANTOM READ가 발생할 수 있다. PHANTOM READ는 트랜잭션 내에서 같은 쿼리를 실행했을 때 레코드가 보였다 안보였다 하는 것이다.
- 사용자가 INSERT하는 도중에 다른 사용자가 SELECT ... FOR UPDATE를 실행하면 PHANTOM READ가 발생한다.
- SELECT ... FOR UPDATE는 SELECT하는 레코드에 쓰기 잠금을 걸어야하는데 언두 레코드에는 쓰기 잠금을 걸 수 없기 때문에 PHANTOM READ가 발생한다.

#### SERIALIZABLE
- 가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준이다. 
- Non-locking consistent read(잠금이 필요 없는 일관된 읽기)라는 말이 이를 의미한다. 
- SERIALIZABLE이 설정되면 읽기 작업도 읽기 락을 획득해야만 하며, 동시에 다른 트랜잭션은 해당 레코드에 대한 읽기와 쓰기 작업을 할 수 없다.
- 하지만 InnoDB에서는 갭 락과 넥스트 키 락 덕분에 REAPEATABLE READ에서도 PANHTOM READ가 발생하지 않아 굳이 SERIALIZABLE을 사용할 필요가 없다.

## Lock (MySQL 기준)
- Lock은 동시성을 제어하기 위한 기능이다.
- MySQL에서 사용되는 Lock은 크게 스토리지 엔진 레벨의 Lock과 MySQL 엔진 레벨 Lock으로 나뉜다.  

### MySQL 엔진 레벨의 잠금

#### 글로벌 락
- MySQL에서 제공하는 Lock 가운데 가장 범위가 크다.
- `FLUSH TABLES WITH READ LOCK` 명령어으로 획득할 수 있다.
- 영향을 미치는 범위는 MySQL 서버 전체이다.
- 보통 백업을 위해 사용하나 InnoDB 스토리지 엔진을 사용하게되면서 조금 더 가벼운 백업 락을 사용한다.

#### 테이블 락
- 개별 테이블 단위로 설정되는 Lock이다.
- 명시적으로는 `LOCK TABLES table_name READ/WRITE` 명령어로 설정할 수 있다.
- 명시적으로 획득한 Lock은 `UNLOCK TABLES` 명령어로 해제해야한다.
- 묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
- InnoDB 테이블은 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 묵시적인 테이블 락이 발생하지 않는다.

#### 네임드 락
- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정한다.
- RELEASE_LOCK() 함수로 잠금을 해제한다.
- 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용할 수 있다.

#### 메타데이터 락
- 데이터베이스 객체(테이블이나 뷰)의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.
- 명시적으로 획득하거나 해제하는 것이 아니라 테이블 이름 변경하는 경우 자동으로 획득하는 잠금이다. 
- `RENAME TABLE tab_a TO tab_b` 명령어를 실행하면 tab_a와 tab_b에 대한 메타데이터 락을 획득한다.

### MySQL InnoDB 스토리지 엔진 레벨의 잠금
- InnoDB 스토리지 엔진은 레코드 단위의 락을 제공한다.

#### 레코드 락
- 레코드 자체만을 잠그는 것을 레코드 락이라한다. 
- InnoDB의 스토리지 엔진은 다른 DBMS와 달리 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
- 인덱스가 하나도 없더라도 자동생성 된 클러스터 인덱스를 이용해 잠금을 설정한다. 

#### 갭 락
- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠근다. 
- 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것이다.

#### 넥스트 키 락 
- 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금이다. 
- 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 리플리카 서버에서 실행될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장해주는 것이 주목적이다.

#### 자동 증가 락
- 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT라는 칼럼 속성을 제공한다. 
- 이 속성을위해 InnoDB에서는 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용한다. 
- 이 락은 INSERT와 REPLACE와 같이 새로운 레코드를 저장하는 쿼리에서만 사용된다. 
- 자동 증가 락은 잠금을 최소화하기 위해 한 번 증가하면 절대 자동으로 줄어들지 않는다.

## MVCC(MySQL InnoDB) Multi Version Concurrency Control
- MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기(Non-Locking Consistent Read)를 제공하는 것이다.
- InnoDB는 언두 로그를 이용해 MVCC를 구현한다.
- 하나의 레코드에 대해 2개 이상의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 결정한다.

### 작동 방식 
```SQL
CREATE TABLE member (
   id INT NOT NULL,
   name VARCHAR(20) NOT NULL,
   area VARCHAR(20) NOT NULL,
   PRIMARY KEY (id)
   INDEX idx_area(area)
);

INSERT INTO member VALUES (12, '홍길동', '서울');
COMMIT;
```

격리 수준 READ_COMMITED에서 INSERT 문이 실행되고 난후 다음 UPDATE를 실행하는 경우 나타나는 현상을 살펴보자. 

```SQL
UPDATE member SET area = '경기' WHERE id = 12;
```

| 저장 위치       | 값(id/name/area) |
|-------------|-----------------|
| InnoDB 버퍼 풀 | 12/홍길동/경기       |
| 언두 로그       | 12/홍길동/서울       |
| 데이터 파일      | 12/홍길동/?        |

1. UPDATE 문장이 실행되면 커밋 실행여부와 관계없이 InnoDB의 버퍼 풀은 새로운 값 `경기`로 업데이트된다.
2. 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드에 의해 새로운 값으로 업데이트돼 있을 수도 있고 아닐 수도 있다.(InnoDB는 ACID를 보장하기에 일반적으로 버퍼 풀과 데이터 파일을 동일한 상태라고 가정해도 무방하다.)
3. COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 SELECT 쿼리를 실행하는 경우를 살펴보자.

```SQL
SELECT * FROM member WHERE id = 12;
```

- 위 SELECT 쿼리를 실행하면 설정된 격리 수준에 따라 다르다. READ_UNCOMMITTED에서는 InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다. 
- READ_COMMITTED나 그 이상의 격리 수준에서는 아직 커밋되지 않았기 때문에 InnoDB 버퍼풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환한다.
- 이러한 과정을 DBMS에서는 MVCC라고 표현한다.
- 이 상태에서 COMMIT이 되면 InnoDB는 더 이상의 변경작업 없이 지금의 상태를 영구적인 데이터로 만들어버린다. 
- 롤백을 실행하면 언두 영역에 있는 백업된 데이터를 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제한다.

> InnoDB 버퍼 풀 
> - 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간  
> - 쓰기 작업을 지연시켜 일괄 작업을 처리할 수 있게 해주는 버퍼 역할도 같이 한다. 

# 참고 문서

- [Spring Boot Roadmaps](https://roadmap.sh/spring-boot)
- [Spring framework core](https://docs.spring.io/spring-framework/reference/core.html)
- [Spring Web Mvc Framework](https://docs.spring.io/spring-framework/reference/web/webmvc.html)
- [김영한 Spring 핵심 원리](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8)
- [김영한 Spring MVC 1](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1)
- Real MySQL ch.4 아키텍처
- Real MySQL ch.5 트랜잭션과 잠금
- [망나니 개발자님 블로그](https://mangkyu.tistory.com/298)
- [싱글톤](https://1-7171771.tistory.com/121)
- [필터 vs 인터셉터 차이 및 용도](https://mangkyu.tistory.com/173)
- [정규화](https://mangkyu.tistory.com/110)
- 어댑터 패턴
- 프록시 패턴
- 데코레이터 패턴
- 싱글톤 패턴
- 팩토리 패턴
- 데이터 베이스 
  - 각종 데이터 베이스와 비교 (MySQL, PostgreSQL)
- Spring Transactional 옵션들
- 기획(게시판)

# 디자인 패턴

## 생성형 패턴

### 싱글턴 패턴
어떤 클래스의 객체 또는 인스턴스를 단 하나만 생성할 수 있는 패턴

#### 싱글턴 패턴의 구현

싱글턴 패턴을 구현하는데는 4가지 조건을 중점에 두자. 

1. 생성자는 private으로 선언하여 new 예약어를 통한 인스턴스의 생성을 막는다. 
2. 객체가 생성될 때 스레드 안전성을 보장하는지 확인하자. 
3. 지연 로딩을 지원하는지 여부를 확인하자. 
4. getInstance() 함수의 성능이 충분해야 한다. 

##### 즉시 초기화(eager initialization)
- 인스턴스는 클래스가 메모리에 적재될 때 이미 생성되어 초기화가 완료된다.
- 인스턴스 생성 프로세스는 스레드가 안전하다고 보장할 수 있다.
- 단점은 lazy loading을 지원하지 않기 때문에, 인스턴스는 사용되는 시점이 아니라 미리 생성된다. 

```Java
public class IdGenerator1 {
    private AtomicLong id = new AtomicLong(0L);
    private static final IdGenerator1 instance = new IdGenerator1();

    private IdGenerator1() {}
    public static IdGenerator1 getInstance() {
        return instance;
    }

    public long getId() {
        return id.incrementAndGet();
    }
}
```

##### 지연 초기화(lazy initialization)
- lazy loading을 지원한다.
- 인스턴스의 생성과 초기화가 실제로 사용되기 전까지 일어나지 않는다. 

```Java
public class IdGenerator2 {
    private AtomicLong id = new AtomicLong(0L);
    private static IdGenerator2 instance;

    private IdGenerator2() {}
    public static synchronized IdGenerator2 getInstance() {
        if (instance == null) {
            instance = new IdGenerator2();
        }
        return instance;
    }

    public long getId() {
        return id.incrementAndGet();
    }
}
```

###### 단점
- 지연 초기화 방식이 lazy loading을 지원하기는 하지만 성능이슈가 발생할 수 있다. 
  - 시간이 오래 걸리는 초기화 작업이 인스턴스가 사용되기 직전에 이루어지면 시스템 성능이 저하될 수 있다.
  - 인스턴스가 많은 리소스를 차지한다면, 문제가 있다면 빨리 노출시키는 fail-fast 설계 원칙에 따라 프로그램이 시작될 때 인스턴스가 초기화가 완료되는 것이 합리적이다.
  - 프로그램이 시작되는 시점에 PermGen Space OOM과 같은 오류가 발생하므로 빠르게 수정할 수도 있다. 
  - 최대한 런타임 오류를 줄이는게 좋다. 
- 병목현상이 발생할 수 있다.
  - getInstance() 메소드에 synchronized 키워드를 사용하면, 해당 메소드는 한 번에 하나의 스레드만 접근할 수 있기 때문에 병목현상이 발생할 수 있다.
  - 사용빈도가 낮다면 괜찮겠지만 사용빈도가 높다면 Lock이 빈번하게 일어나 동시성 문제로 인해 병목현상이 발생한다. 

##### 이중 잠금(Double-Checked Locking)
- 즉시 초기화방식은 lazy loading을 지원하지 않고, 지연 초기화 방식은 높은 동시성을 지원하지 않는다.
- 이중 잠금 방식은 즉시 초기화 방식의 성능을 유지하면서도 lazy loading을 지원한다.

```Java
public class IdGenerator3 {
    private AtomicLong id = new AtomicLong(0L);
    private static IdGenerator3 instance;

    private IdGenerator3() {}

    public static IdGenerator3 getInstance() {
        if (instance == null) {
            synchronized (IdGenerator3.class) { // 클래스 레벨의 잠금처리
                if (instance == null) {
                    instance = new IdGenerator3();
                }
            }
        }
        return instance;
    }

    public long getId() {
        return id.incrementAndGet();
    }
}
```

###### 단점
- CPU 명령이 재정렬되면 IdGenerator 클래스의 객체가 new 예약어를 통해 instance 멤버 변수가 지정된 후, 초기화가 이루어지기 전에 다른 스레드에서 이 객체를 사용하려고 할수 있다. 
- 이러한 문제를 해결하기 위해 volatile 키워드를 인스턴스 멤버 변수에 추가하여 명령어 재정렬을 방지한다.

###### CPU 명령어 재정렬 (Instruction Reordering)
- 컴파일러나 CPU가 프로그램의 실행 순서를 최적화하여 성능을 향상시키기 위해 명령어의 실행 순서를 변경하는 것
- 단일 스레드 환경에서는 문제가 되지 않지만, 멀티스레드 환경에서는 데이터의 일관성을 해칠 수 있다.
 
###### volatile 키워드
volatile 키워드는 자바에서 멀티스레딩 환경에서 변수의 값을 항상 메인 메모리에서 읽고 쓰도록 보장한다. 재정렬 문제를 방지함.

##### 홀더에 의한 초기화(Initialization on Demand Holder Idiom)
- 이중 잠금보다 간단한 방식으로 Java의 정적 내부 클래스를 사용하는 방식
- 즉시 초기화 방식과 유사하지만 지연로딩이 가능하다는 장점이 있다. 

```Java
public class IdGenerator4 {
    private AtomicLong id = new AtomicLong(0L);

    private IdGenerator4() {}

    private static class SingletonHolder {
        private static final IdGenerator4 instance = new IdGenerator4();
    }

    public static IdGenerator4 getInstance() {
        return SingletonHolder.instance;
    }

    public long getId() {
        return id.incrementAndGet();
    }
}
```

- SingletonHolder는 정적 내부 클래스로, 외부 클래스인 IdGenerator4의 인스턴스가 생성되는 시점에는 로딩되지 않는다.
- 대신 getInstance() 메소드가 호출되는 시점에 로딩되며, 이때 클래스 초기화가 이루어진다. 이때 인스턴스의 유일성과 스레드 안전성은 JVM에 의해 보장된다.

##### Enum을 이용한 싱글턴 패턴
- Enum이 가지는 특성을 이용하여 인스턴스 생성 시 스레드 안전성과 인스턴스의 유일성을 보장한다. 

```Java
public enum IdGenerator5 {
    INSTANCE;

    private AtomicLong id = new AtomicLong(0L);

    public long getId() {
        return id.incrementAndGet();
    }
}
```  

#### 싱글턴 패턴의 단점 
1. 클래스 간의 의존성을 감춘다. 
   - 싱글턴 클래스는 명시적으로 생성할 필요가 없고 매개변수 전달에 의존할 필요도 없으며 함수에서 직접 호출할 수 있음에도 의존성이 전혀 드러나지 않는다.
2. 싱글턴 패턴은 코드의 확장성에 영향을 미친다.
   - 하나의 인스턴스만 사용하다 나중에 두 개 이상의 인스턴스가 필요한 경우, 코드를 전면적으로 수정해야 할 수 있다. 
   
# 참고문서
[RFC 6265bis](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-14)  
[mdn HTTP Cookie](https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies)  
[HTTP 완벽가이드](https://www.yes24.com/Product/Goods/15381085)

# Cookie 

## 등장 배경
1994년 넷스케이프 커뮤니케이션즈에 의해 처음 소개되었다.  
웹의 초기에는 상태를 유지할 방법이 없었기 때문에, 사용자 세션 정보를 유지하거나 사용자 개인 설정을 저장하기 어려웠다.  
이를 해결하기 위해 HTTP 쿠키가 도입되었다. 

## 정의 
클라이언트와 서버 간의 상태 정보를 유지하기 위해 서버가 클라이언트에게 보내는 작은 데이터 조각

## 특징
1. 작은 데이터: 주로 key-value 쌍 형태로 구성된 작은 데이터 파일
2. 클라이언트-서버 간 교환: 클라이언트(브라우저)와 서버 간에 자동으로 전송됨
3. 제한된 크기: 각 쿠키는 4KB 이하의 데이터만 저장할 수 있음
4. 수명: 특정 기간 동안 유지되며, 만료 날짜를 지정할 수 있음

## 목적 
1. 세션 관리(Session management)
   - 서버에 저장해야 할 로그인, 장바구니, 게임 스코어 등의 정보 관리
2. 개인화(Personalization)
   - 사용자 선호, 테마 등의 세팅
3. 트래킹(Tracking)
   - 사용자 행동을 기록하고 분석하는 용도

> 과거에는 클라이언트 측에 정보를 저장할 때 쿠키를 사용했으나(쿠키를 사용하는 게 데이터를 클라이언트에 저장하는 유일한 방법 이었을 때) 현재는 localStorage, sessionStorage, IndexedDB 등의 웹 스토리지 API를 사용하는 것이 더 효율적이다.  
> 모든 요청마다 쿠키가 함께 전송되기 때문에 불필요한 데이터 전송이 발생할 수 있으며, 쿠키는 서버에 전송되기 때문에 네트워크 트래픽이 발생한다.

## 사용 방법
1. 서버에서 클라이언트로 쿠키를 설정
    ```HTTP
    Set-Cookie: sessionId=woojong; Expires=Tus, 21 May 2024 07:28:00 GMT; Secure; HttpOnly
    ```
2. 클라이언트는 쿠키를 저장하고, 다음 요청 시 서버로 쿠키를 전송  
    ```HTTP
    Cookie: sessionId=woojong
    ```

### 쿠키 속성
| 속성       | 설명                                    |
|----------|---------------------------------------|
| Expires  | 쿠키 만료 날짜                              |
| Max-Age  | 쿠키 만료 시간(초)                           |
| Domain   | 쿠키가 전송될 도메인                           |
| Path     | 쿠키가 전송될 경로                            |
| Secure   | HTTPS 연결일 때만 쿠키 전송                    |
| HttpOnly | JavaScript에서 쿠키 접근 불가                 |
| SameSite | 요청 도메인과 동일한 도메인일 때만 쿠키 전송할 수 있는 옵션 제공 |

- XSS([Cross-Site Scripting](https://developer.mozilla.org/ko/docs/Glossary/Cross-site_scripting)) : 공격자가 웹사이트에 악성 클라이언트 사이드 코드를 삽입할 수 있도록 하는 보안 취약점 공격  
  - HttpOnly 속성을 사용하면 JavaScript에서 쿠키에 접근할 수 없어 XSS 공격을 방지할 수 있음 (Document.cookie 사용 불가). 
  - 서버 쪽에서 지속되고 있는 세션의 쿠키는 JavaScript를 사용할 필요성이 없기 때문에 HttpOnly 속성을 사용하는 것이 좋음
- CSRF([Cross-Site Request Forgery](https://developer.mozilla.org/ko/docs/Glossary/CSRF)) : 신뢰할 수 있는 사용자를 사칭해 웹 사이트에 원하지 않는 명령을 보내는 공격
  - SameSite 속성을 사용하면 요청 도메인과 동일한 도메인일 때만 쿠키를 전송하도록 설정할 수 있음


## 사용시 주의해야 할 점
1. 보안 
   - 중요한 정보는 저장하지 않는 것이 좋음
   - Secure, HttpOnly 속성을 사용하여 보안 강화
2. 개인정보 보호
   - 사용자 추적과 관련된 쿠키 사용에 대해 명확한 고지와 동의를 받아야 함
3. 쿠키 크기 및 수 제한
   - 브라우저마다 저장할 수 있는 쿠키의 수와 크기에 제한이 있으므로, 이를 고려하여 관리

### 서드파티 쿠키
- 서드파티 쿠키는 현재 방문 중인 사이트의 도메인이 아닌 다른 도메인에서 설정한 쿠키를 말한다. 
- 사용자의 개인정보를 수집하거나 사용자를 추적하는 데 사용될 수 있으므로, 사용자의 동의 없이 서드파티 쿠키를 사용하는 것은 위험하다.

## 라이프 타임에 따른 분류

1. 세션 쿠키(Session Cookie)
   - 브라우저가 종료되면 삭제되는 쿠키
   - Expires, Max-Age 속성을 설정하지 않으면 세션 쿠키로 설정됨
   - 주로 서버와 클라이언트 간의 상태를 유지하기 위해 사용
2. 지속 쿠키(Persistent Cookie)
   - Expires, Max-Age를 설정하여 지정된 날짜까지 유지되는 쿠키
   - 브라우저를 닫아도 유지된다.

# Session

## 정의
사용자와 서버 간의 상호작용 동안 상태를 유지하기 위한 방법이다.  
서버 측에 저장된 데이터와 이를 식별하기 위한 세션 ID로 구성된다.  

## 특징
1. 유지 시간: 세션은 일정 시간 동안 지속되며, 유휴 시간(사용자가 활동하지 않는 시간)이 길어지면 만료될 수 있습니다.
2. 고유 식별자: 각 세션은 고유한 세션 ID를 가지고 있으며, 이는 일반적으로 예측 불가능한 난수로 생성됩니다.
   - '일반적으로 예측 불가능한 난수로 생성한다는 의미'는 대부분의 어플리케이션이 session Id를 생성할 때 보안성 강화를 위해 예측하기 어려운 난수를 생성한다는 의미이다.
3. 서버 측 저장: 세션 데이터는 서버 측에 저장되며, 클라이언트는 세션 ID만 가지고 있습니다.
    - 서버의 수가 많아지면, 서버마다 세션데이터를 가지기 때문에 클라이언트에서 서버로 요청을 보낼 때 세션을 공유할 수 없는 문제가 생긴다.
    - 이 문제를 해결하기 위해 세션 공유, 스티키 세션, 세션 클러스터링, 데이터베이스 세션관리, 토큰 기반 인증 방법을 이용할 수 있다. 
      - 세션 공유: 모든 서버가 공통으로 접근할 수 있는 세션 저장소를 사용한다. Redis, Memcached 등을 사용할 수 있다.
      - 스티키 세션: 로드벨런서를 사용하여 사용자의 첫 요청을 특정 서버에 고정 시키는 방법 
      - 세션 클러스터링: 하나의 세션 저장소에서 변경되는 사항이 발생하면 모든 세션에 복제되도록 하는 방법
      - 데이터베이스 세션관리: 세션 데이터를 데이터베이스에 저장하는 
      - 토큰 기반 인증: 세션 대신 토큰을 사용하여 사용자를 인증하는 방법
4. 상태 유지: 사용자의 로그인 상태, 장바구니 정보 등 다양한 상태 정보를 유지할 수 있습니다.

[OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html) 문서에는 세션 관리에 대한 보안에 대한 다양한 정보가 포함되어 있다. 

### Session ID
- Session ID는 세션을 고유하게 식별하는 문자열이다. 안전한 세션 ID는 예측할 수 없고 충분히 길어야 하며, 난수 생성기를 사용하여 생성해야 한다.
- Sessopm ID 길이: 최소 128비트의 난수를 사용해야 한다.

#### Session ID 생성 방법
1. UUID(Universally Unique Identifier) : 고유한 식별자를 생성하는 표준 방법
2. 암호학적으로 안전한 난수 생성기(Cryptographically Secure Pseudorandom Number Generator) : 난수 생성기를 사용하여 무작위로 생성
3. 해싱 : 사용자의 IP 주소, User-Agent, 시간 등을 조합하여 해싱한 값을 사용

## 목적
1. 사용자 인증 상태 유지 : 로그인 상태 유지, 사용자 식별
2. 사용자 상태 : 장바구나, 사용자 설정
3. 보안 : 세션 타임아웃, 활동 추적
4. 사용자 경험 개선 : 사용자가 일관된 상태를 유지함
5. 트랜잭션 관리 : 여러 단계로 구성된 프로세스 작업에서 각 단계의 입력값을 세션에 저장하여 중간에 중단했다가 다시 시작해도 이전 입력값 유지, 복잡한 트랜잭션의 상태를 세션에 저장하여 트랜잭션의 일관성을 유지.

## 사용시 주의해야 할 점

### 세션 고정 공격 방지
사용자가 인증에 성공하면 새로운 세션 ID를 생성하여 기존 세션을 대체해야 한다.
### 세션 하이재킹 방지 
세션을 특정 IP 주소나 User-Agent에 바인딩하여 다른 환경에서 세션을 사용할 수 없도록 한다.
### Session Id의 보호
Session Id는 전송 중 보호를 위해 Secure 속성을 사용해야하고, 저장 중 보호를 위해 HttpOnly 속성을 사용해야 한다.
### Session 시간 설정
- 쿠키를 기반으로 하는 세션 관리의 경우 일반적으로 세션 쿠키(비영구 쿠키)를 사용한다.
- 세션 만료는 유휴 시간 또는 전체 사용 시간에 따라 만료시켜야한다.
    - 유휴 시간 만료: 사용자가 일정 시간 동안 활동하지 않으면 세션 만료
    - 전체 사용 시간 만료: 사용자가 일정 시간 동안 활동하더라도 세션 만료
### 로그아웃 처리
사용자가 로그아웃할 때 서버 측에서 세션을 무효화하고, 클라이언트 측에서도 세션 ID가 저장된 쿠키를 삭제합니다.
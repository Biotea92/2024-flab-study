# 프로젝트 패키지 구조

## Layered Architecture

소프트웨어 시스템을 계층별로 나누어 설계하는 아키텍처 스타일이다.  
각 계층은 특정 기능과 책임을 가지며, 상위 계층은 하위 계층에 의존하지만, 하위 계층은 상위 계층에 대해 알지 못한다.  
이는 시스템의 복잡성을 줄이고, 유지보수성과 재사용성을 높인다.  
일반적으로 네 개의 주요 계층으로 나뉘며 프레젠테이션 계층, 어플리케이션 계층, 도메인 계층, 데이터 소스 계층 이다.

### 계층
#### 프레젠테이션 계층
사용자와 상호작용하는 계층  
주로 UI를 담당하며, 사용자 입력을 받아들여 애플리케이션 계층으로 전달하고, 결과를 사용자에게 표시한다.  

- 역할 : 사용자 인터페이스 처리, 입력 검증, 출력 포맷팅

#### 어플리케이션 계층
비즈니스 로직을 처리하는 계층  
사용자의 요청을 처리하고, 도메인계층을 호출하여 필요한 작업을 수행한 후 결과를 프레젠테이션 계층으로 반환한다.

- 역할 : 비즈니스 로직 처리, 유스 케이스 실행, 워크플로우 제어 

#### 도메인 계층
시스템의 핵심 비즈니스 도메인 로직과 엔터티를 포함한다. 이 계층은 시스템의 비즈니스 규칙과 정책을 캡슐화한다. 

- 역할 : 비즈니스 규칙, 도메인 객체 관리, 상태 전이

#### 데이터 소스 계층
데이터베이스와 같은 외부 데이터 소스와의 상호작용을 담당한다.

### 패키지 예시 
```
com.example.project
 ├── config
 │    └── AppConfig.java
 ├── api
 │    ├── controller
 │    │    └── UserController.java
 │    └── serivce
 │         └── UserService.java
 ├── client
 │    └── MailSendClient.java
 ├── domain
 │    ├── User.java
 │    └── UserRepository.java   
 ├── exception
 │    └── UserNotFoundException.java
 └── util
      └── PageUtil.java
```

## Hexagonal Architecture
포트와 어댑터 아키텍처로도 알려져 있다. 

### 핵심 개념

#### 도메인 (Domain)
시스템의 핵심 비즈니스 로직과 규칙을 포함하는 부분입니다. 이 계층은 외부 기술에 독립적이어야 하며, 오직 도메인 로직에만 집중한다.

#### 포트 (Ports)
도메인 계층이 외부와 상호작용하기 위해 사용하는 인터페이스이다. 포트는 입력 포트(도메인으로 들어오는 요청)와 출력 포트(도메인에서 나가는 요청)로 나눌 수 있다.

#### 어댑터 (Adapters)
포트를 구현하여 외부 시스템과 도메인 계층을 연결하는 역할을 한다.  
어댑터는 입력 어댑터(예: REST 컨트롤러, 메시지 리스너)와 출력 어댑터(예: 데이터베이스 리포지토리, 외부 API 클라이언트)로 나눌 수 있다.

### 다이어그램 
```
          --------------------
         |    External World   |
          --------------------
                  |
      ------------------------
     |      Input Adapters      | (예: REST Controllers, UI)
      ------------------------
                  |
          ----------------
         |     Ports      |
          ----------------
                  |
          ----------------
         |    Domain      |
          ----------------
                  |
          ----------------
         |     Ports      |
          ----------------
                  |
      ------------------------
     |      Output Adapters     | (예: Repositories, External APIs)
      ------------------------
                  |
          --------------------
         |    External World   |
          --------------------

```

### 패키지 예시
```
com.example.project
 ├── application
 │    ├── ports
 │    │    ├── input
 │    │    │    └── UserService.java
 │    │    └── output
 │    │         └── UserRepository.java
 │    └── services
 │         └── UserServiceImpl.java
 ├── domain
 │    ├── model
 │    │    └── User.java
 │    └── exceptions
 │         └── UserNotFoundException.java
 ├── adapters
 │    ├── input
 │    │    └── rest
 │    │         └── UserController.java
 │    └── output
 │         └── persistence
 │              ├── UserEntity.java
 │              ├── SpringDataUserRepository.java
 │              └── UserRepositoryAdapter.java
 └── config
      └── AppConfig.java
```



## 내용

프로젝트의 패키지 구조는 대표적으로 Package by Layer 와 Package by Feature 가 있습니다. 

## Package by Layer

- 프로젝트의 계층별로 패키지를 구성하는 방식 
- 패키지에 서로 밀접하게 관련되지 않은 클래스가 포함되어 있기 때문에 패키지내 응집력(Cohesion)이 감소된다
- `Repository`는 `Service`에서 사용되고, `Service`는 `Controller`에서 사용될 것이므로 패키지들간 높은 결합이 생긴다. 

> Cohesion :   
> 패키지 멤버 간의 논리적 관련성을 의미한다.  
> 높은 응집력은 패키지의 독립성을 보장하고, 낮은 응집력은 독립성을 감소 시키고 재사용성과 이해도를 감소시킨다. 
> 
> Coupling :  
> 패키지들 간의 상호 의존성 정도를 의미한다.
> 낮은 결합은 유지보수성을 향상시킨다. 
> 
>> 좋은 시스템 설계를 위해서는 패키지 내 높은 응집력과 패키지간 낮은 결합도가 필수적이다. 

```
├── com.app
    └── controller
        ├── PostController
        ├── ProductController
        └── UserController
    └── model
        ├── Post   
        ├── Product
        └── User
    └── repository
        ├── PostRepository   
        ├── ProductRepository
        └── UserRepository
    └── service
        ├── PostService
        ├── ProductService
        └── UserService
    └── util
```

## Package by Feature

- 프로젝트의 기능별로 패키지를 구성하는 방식
- 패키지에는 서로 관련된 클래스만 포함되어 있기 때문에 패키지내 응집력이 높아진다.
- 다른 패키지의 클래스에서 클래스를 사용하는 것이 제거되기 때문에 결합도가 낮아진다. 

```
├── com.app
    └── post
        ├── Post
        ├── PostController
        ├── PostRepository        
        └── PostService
    └── product
        ├── Product   
        ├── ProductController
        ├── ProductRepository
        └── ProductService
    └── util
    └── user
        ├── User   
        ├── UserController
        ├── UserRepository
        └── UserService
```

- 만약 MSA로 마이그레이션한다고 가정하면 Package by Feature가 더 적합하다.


### 멀티 모듈 
`storage / api-user / api-admin / support` 모듈 구조에서는 onion architecture와 비슷하게 이용할 예정입니다.


- storage 
```
domain
  ├── user
  │   ├── entity
  │   │   └── User.java
  │   ├── services
  │   │   └── UserService.java
  │   └── repository
  │       └── UserRepository.java
  └── post
      ├── entity
      │   └── Post.java
      ├── service
      │   └── PostService.java
      └── repository
          └── PostRepository.java

```

- api-user, api-admin

```
├── application
│   ├── user
│   │   ├── usecases
│   │   │   └── RegisterUserUseCase.java
│   │   └── dto
│   │       └── UserDto.java
│   └── post
│       ├── usecases
│       │   └── GetPostUseCase.java
│       └── dto
│           └── PostDto.java
└── presentation
    ├── user
    │   ├── dto
    │   │   └── UserResponse.java
    │   ├── controller
    │   │   └── UserController.java
    │   └── exception
    │       ├── UserExceptionHandler.java
    │       └── UserNotFoundException.java
    └── post
        ├── dto
        │   └── PostResponse.java
        ├── controller
        │   └── PostController.java
        └── exception
            ├── PostExceptionHandler.java
            └── PostNotFoundException.java
```

- support
```
support
├── exceptions
│   ├── CustomException.java
│   └── ErrorDetails.java
└── utils
    ├── DateUtils.java
    └── StringUtils.java

```


- infrastructure(추가)

```
infrastructure
├── persistence
│   ├── user
│   │   └── UserJpaRepository.java
│   └── post
│       └── PostJpaRepository.java
├── config
│   ├── JpaConfig.java
│   └── SecurityConfig.java
└── external
    └── ExternalPaymentService.java
```


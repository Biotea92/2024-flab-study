# 피드백 정리 

> 1. `EnableWebSecurity` 의 역할은 무엇인가요. 없어도 제대로 작동하나요 ?  
> 2. `Configuration` 어노테이션의 역할은 무엇인가요 ? `proxyBeanMethods` 의 옵션에 대해 살펴보시겠어요 ?  

1. `@EnableWebSecurity` 는 Spring Security를 사용하기 위한 설정을 활성화하는 어노테이션입니다.(무엇보다도 SecurityFilterChain를 빈으로 등록합니다.)
이 어노테이션을 사용하지 않아도 Spring boot의 자동 설정을 통해 Spring Security가 적용됩니다.
하지만, `@EnableWebSecurity` 를 사용하면 Spring Security 를 커스터마이징 할 수 있습니다. 

2. `Configuration`이 적용된 클래스는 스프링의 설정 클래스를 의미합니다. 내부에 `@Bean` 어노테이션으로 메서드는 Ioc 컨테이너에 관리되는 빈을 등록합니다.
   - `proxyBeanMethods` 옵션은 설정 클래스에서 빈이 적용된 메서드 호출이 프록시를 통해 수행되는지 여부를 결정합니다. 
       - true(기본값): 내부의 빈 메서드를 호출하면 실제로는 프록시를 통해 빈 메서드가 호출됩니다. -> 같은 빈이 여러번 생성되는 것을 방지
       - false: 빈 메서드를 직접 호출합니다. -> 새로운 빈이 생성됩니다.


> `.csrf(AbstractHttpConfigurer::disable)` AbstractHttpConfigurer 은 무엇인가요

- `AbstractHttpConfigurer`는 Spring Security에서 HTTP 보안 설정을 구성하기 위한 추상 클래스입니다.  
- 다양한 보안 설정을 활성화하거나 비활성활 할 수 있는 메서드를 가지며, 이를 상속받아 커스텀할 수 있습니다. 
- `csrf`를 비활성화 한 이유는 현재 개발하기 위한 테스트를 위해서 입니다.

> `BCryptPasswordEncoder` 는 무엇이며, 대채제는 없나요 ?

`BCryptPasswordEncoder`는 기본적으로 Security에서 제공하는 단방향 해시 알고리즘을 적용한 encoder입니다.  
특징 중 하나는 `salt`를 이용하여 같은 비밀번호라도 다른 해시값을 생성하여 보안성을 높입니다.  
이외의 대체제로는 Security에서 기본제공하는 `SCryptPasswordEncoder`, `Pbkdf2PasswordEncoder`가 있습니다.  
그 외에도 Argon2과 같은 외부 라이브러리를 사용할 수 있습니다.

이들을 선택할 때의 기준은 보안성, 성능, 메모리 사용량 등을 고려합니다. 

> 그럼에도 불구하고, `BCryptPasswordEncoder` 를 선택한 이유?


> 1. readOnly 의 역할은 무엇인가요.  
> 2. read 는 기본적으로 DB 에서 MVCC 형태로 작동을 하는데, 굳이 트랜잭션을 사용해야할까요 ?

1. `readOnly`는 데이터베이스에 대한 읽기 전용 트랜잭션을 설정하는 속성입니다.  
   - true: 트랜잭션 내에서 데이터베이스에 대한 읽기 작업만 수행할 수 있습니다.  
   - false: 트랜잭션 내에서 데이터베이스에 대한 읽기 및 쓰기 작업을 수행할 수 있습니다.
     다른 ORM에서는 DB에서 MVCC 형태로 작동하지만 Hibernate 구현체에서는 영속성 컨텍스트 관리를 위한 추가 작업이 필요하기에
     class 위에 readOnly=true를 붙여주었습니다.
     > You can use transactions for read-only queries and mark them as such by setting the readOnly flag. Doing so does
     not, however, act as a check that you do not trigger a manipulating query (although some databases reject INSERT
     and UPDATE statements inside a read-only transaction). The readOnly flag is instead propagated as a hint to the
     underlying JDBC driver for performance optimizations. Furthermore, Spring performs some optimizations on the
     underlying JPA provider. For example, when used with Hibernate, the flush mode is set to NEVER when you configure a
     transaction as readOnly, which causes Hibernate to skip dirty checks (a noticeable improvement on large object
     trees).

> 다시 학습해봐주세요. READ 후에 WRITE/UPDATE 오퍼레이션이 없는 경우에 추가 작업이 필요할까요 ? 나아가, MVCC 의 취지는 트랜잭션 lock 을 최소화 하기 위함입니다. ORM 을 사용함으로써
> 해당 부분을 이용할 수 없다는 것은 ORM 의 치명적인 단점으로 받아들여지는데 어떻게 생각하시나요 ?